---
createdAt: 2026-01-11
updatedAt: 2026-01-11
title: `vite-env-only` & Intlayer – хибнопозитивна помилка відхилення `node:fs`
description: Чому vite-env-only повідомляє про відхилений імпорт `node:fs` з Intlayer + React-Router + Vite і що робити.
keywords:
  - intlayer
  - vite
  - react-router
  - vite-env-only
  - node:fs
  - відхилений імпорт
  - alias
  - клієнтський бандл
slugs:
  - frequent-questions
  - vite-env-only-node-fs-false-positive
---

# vite-env-only відхиляє `node:fs` в Intlayer

Якщо ви використовували плагін **vite-env-only** (як зазначено в старих рекомендаціях React-Router v7) і бачите:

```bash

Error: [vite-env-only] Import denied

* Denied by specifier pattern: /^node:/
* Importer: index.html
* Import: "node:fs"

```

…незважаючи на те, що **в клієнтському бандлі немає `node:fs`**, це — **хибне спрацювання**.

## Чому це відбувається

`vite-env-only` виконує перевірку на основі Babel **на ранньому етапі резолюції графа Vite**, _перед_:

- aliasing (включаючи відповідності Intlayer для browser vs node),
- dead-code elimination,
- SSR vs client resolution,
- віртуальні модулі, як-от ті в React-Router.

Пакети Intlayer містять код, який може працювати як у Node, так і в браузері. На _проміжному_ етапі в графі може з'явитися вбудований модуль Node, наприклад `node:fs`, **перед тим як** Vite видалить його з клієнтської збірки. `vite-env-only` помічає це і відразу видає помилку, хоча у фінальному бандлі його немає.

## React-Router і серверні модулі

У документації React-Router щодо **конвенцій серверних модулів**
(https://reactrouter.com/api/framework-conventions/server-modules), команда **чітко рекомендує використовувати `vite-env-only`**, щоб запобігти потраплянню імпортів, призначених лише для сервера, у клієнтський бандл.

Однак ці конвенції покладаються на aliasing Vite, conditional exports і tree-shaking для видалення коду, призначеного лише для сервера. Хоча aliasing і conditional exports вже застосовані, деякі утиліти на основі Node все ще присутні в пакетах на кшталт `@intlayer/core` на цьому етапі (хоча вони ніколи не імпортуються на клієнті). Оскільки tree-shaking ще не відбувся, ці функції все ще парсяться Babel, і `vite-env-only` виявляє їхні імпорти `node:` та породжує false positive — хоча вони коректно очищуються з фінального клієнтського бандлу.

## Як виправити / обійти

### Рекомендовано: Видалити `vite-env-only`

Просто видаліть цей плагін. У багатьох випадках він не потрібен — Vite вже обробляє розрізнення імпортів для клієнта та сервера через власний механізм резолюції.

Це виправляє хибну відмову через `node:fs` без змін в Intlayer.

### Натомість перевірте фінальну збірку

Якщо ви все ще хочете переконатися, що в клієнтському бандлі немає вбудованих модулів Node, робіть це **після збірки**, наприклад:

```bash
pnpm build
grep -R "node:" dist/
```

Якщо результатів немає, ваші клієнтські бандли чисті.

## Підсумок

- `vite-env-only` може видавати помилку на `node:fs`, оскільки перевіряє занадто рано.
- Vite + Intlayer + конвенції server modules у React-Router зазвичай правильно видаляють посилання, призначені тільки для сервера.
- Видалення плагіна або перевірка _фінального виводу_ зазвичай є найкращим рішенням.
