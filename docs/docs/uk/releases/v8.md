---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: "Новий Intlayer v8 - Що нового?"
description: "Дізнайтеся, що нового в Intlayer v8. Значні покращення досвіду розробника, валідації контенту та управління словниками."
keywords:
  - Intlayer
  - CMS
  - Developer Experience
  - Features
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# Новий Intlayer v8 — що нового?

Ласкаво просимо до Intlayer v8! У цьому випуску основна увага приділена покращенню досвіду розробника за допомогою автоматичного виявлення контенту, забезпеченню цілісності даних через валідацію схем і наданню більшого контролю над управлінням словниками.

## Зміст

<TOC levels={[2]} maxDepth={1} />

---

## Підтримка HTML-контенту

Intlayer v8 представляє функцію `html()`, яка дозволяє вставляти вміст, схожий на HTML, у ваші словники та відображати теги як користувацькі компоненти під час виконання. Це ідеально підходить для rich text, що потребує більше, ніж просто Markdown, або коли потрібно вбудувати інтерактивні компоненти у ваш контент.

**Приклад:**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html("Click <CustomLink>here</CustomLink> for more info"),
  },
};
```

**Використання:**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Прямий рендер (стандартні теги працюють автоматично) */}
        {myRichText}

        {/* Налаштування за допомогою .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Використання провайдера для глобального налаштування */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Прямий рендер (стандартні теги працюють автоматично) */}
        {myRichText}

        {/* Налаштування за допомогою .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Використання провайдера для глобального налаштування */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- Прямий рендеринг -->
        <component :is="myRichText" />

        <!-- Кастомізація за допомогою .use() -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Пряме відображення */}
        {myRichText}

        {/* Кастомізація за допомогою .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Прямий рендеринг */}
        {myRichText}

        {/* Кастомізація за допомогою .use() */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- Прямий рендеринг -->
      {@html myRichText}

      <!-- Кастомізація за допомогою .use() -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Для детальнішої інформації див. [документацію з HTML-контенту](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/dictionary/html.md).

---

## Користувацькі переписування URL

Intlayer v8 додає підтримку **користувацьких переписувань URL**, що дозволяє визначати локалізовані шляхи, які відрізняються від стандартної структури `/locale/path`. Це потужна можливість для покращення локального SEO та забезпечення більш природного досвіду користувача для тих, хто не говорить англійською.

**Ключові покращення в v8:**

- **Форматери для фреймворків**: Нові `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite` та `viteRewrite`, які надають ідіоматичний синтаксис шаблонів для кожного роутера.
- **`useRewriteURL` Hook**: Новий клієнтський хук, який безшумно виправляє адресний рядок до «гарної» локалізованої URL-адреси, не спричиняючи навігацій маршрутизатора.
- **Automatic SEO Redirects**: Вбудовані проксі тепер автоматично перенаправляють користувачів з вручну введених канонічних шляхів (наприклад, `/fr/about`) до їх більш привабливих локалізованих версій (наприклад, `/fr/a-propos`).

**Приклад конфігурації:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

Ця функція підтримується «з коробки» в **Next.js** та **Vite** через проксі Intlayer, і її можна легко інтегрувати в інші роутери, такі як **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit** та **Solid Router**.

Для отримання додаткової інформації та посібників з інтеграції див. [документацію Custom URL Rewrites](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/custom_url_rewrites.md).

---

## Markdown MDX та HTML: `.use()`

Intlayer v8 уніфікує API для багатого контенту. Метод `.set()` (використовувався у v7 для Markdown) було перейменовано на [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx), щоб забезпечити послідовний досвід як для Markdown, так і для HTML.

### Крос-фреймворковий Markdown-парсер

Intlayer тепер інтегрує потужний крос-фреймворковий парсер Markdown, який підтримує **MDX**. Це означає, що ви можете використовувати компоненти безпосередньо у вашому Markdown-контенті, так само як в HTML.

- **Підтримка MDX**: Використовуйте компоненти React/Vue/Svelte всередині вашого Markdown.
- **Готово до SSR**: Парсер оптимізований для Server-Side Rendering (SSR), забезпечуючи швидке початкове завантаження та SEO-дружній багатий контент.
- **Уніфікований API**: Використовуйте `.use()` для відображення тегів Markdown/MDX на компоненти вашого застосунку.

**Приклад з Markdown/MDX:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // Синтаксис, схожий на MDX, у Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Див. [документацію з Markdown](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/dictionary/markdown.md) для отримання додаткової інформації.

---

### Розширені значення вставок

У версії v8 значення вставок тепер можуть **приймати React-елементи (або Vue-вузли)** на додаток до рядків і чисел. Це дозволяє вставляти багаті, інтерактивні компоненти безпосередньо у ваші шаблони вставок.

Intlayer тепер надійно обробляє вкладені вузли React і Preact всередині вставок, гарантуючи, що складні UI-структури зберігаються та відображаються правильно.

**Приклад:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // число
          // або
          name: "John", // рядок
          // або
          name: <span>John</span>, // React-елемент
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // число
          // або
          name: "John", // рядок
          // або
          name: <span>John</span>, // React-елемент
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // або
            name: 'John',
            // або
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // число
          // або
          name: "John", // рядок
          // або
          name: <span>John</span>, // елемент Preact
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // число
          // або
          name: "John", // рядок
          // або
          name: <span>John</span>, // елемент Solid
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // число
        // або
        name: "John", // рядок
      })}
    </div>
    ```

  </Tab>
</Tabs>

## Локалізація: новий хук `useIntl`

Новий хук `useIntl()` тепер доступний у React, Next.js та Vue. Він надає прив'язаний до локалі об'єкт `Intl`, який автоматично використовує поточну мову для форматування чисел, дат та іншого, без необхідності вручну передавати локаль.

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## Валідація схем контенту

У Intlayer v8 додано валідацію схем для словників. Тепер ви можете визначати повторно використовувані схеми валідації у вашій конфігурації за допомогою Zod і застосовувати їх до файлів контенту. Це гарантує, що ваш контент завжди відповідає очікуваній структурі, виявляючи помилки під час збірки.

### 1. Визначте схеми

Визначте свої схеми в `intlayer.config.ts`:

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. Застосуйте схеми до словників

Посилайтеся на ключ схеми у визначенні вашого словника:

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- вказує на ключ схеми
  content: {
    title: "About Our Company - Learn More About Us",
    description: "Discover our company's mission, values, and team.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

Якщо вміст не відповідає схемі (наприклад, заголовок занадто короткий), процес збірки виведе помилку.

---

### Покращене автоматичне виявлення вмісту

У v8 Intlayer інтелектуально виявляє синтаксис Markdown, HTML-теги та вставки змінних у рядках вмісту. Це означає, що ви часто можете опустити допоміжні функції такі як `md()`, `html()` або `insert()`.

Ця поведінка увімкнена за замовчуванням. Тепер ви можете тонко налаштувати це виявлення або глобально в `intlayer.config.ts`, або для кожного словника окремо.

#### Гранулярний контроль

Ви можете ввімкнути або вимкнути певні типи трансформацій:

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (за замовчуванням)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // Вимкнути автоматичне виявлення вставок
    },
  },
};
```

**Поведінка v7 (ручне обгортання):**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**Поведінка у v8 (Автоматичне визначення):**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // Також може бути встановлено у визначенні словника або глобально в intlayer.config.ts
  content: {
    myMarkdown: "## Hello World", // Автоматично визначається як Markdown
    myHTML: "<p>Hello World</p>", // Автоматично визначається як HTML
    myInsertion: "Hi {{name}}", // Автоматично визначається як Insertion
  },
};
```

Підлягаючий JSON-результат залишається незмінним, зберігаючи багату інформацію про типи, необхідну для рендерингу:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hello World"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hello World</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## Інструменти: Покращення розширення VSCode

Розширення Intlayer для VSCode отримує значні оновлення у v8, щоб оптимізувати ваш робочий процес інтернаціоналізації:

- **Starting Time**: Покращення продуктивності під час відкриття проєкту.
- **Caching**: Покращений шар кешування для практично миттєвої валідації та автозаповнення.
- **Unused Keys & Duplicated Keys Detection**: Нові функції для автоматичного виявлення **невикористовуваних ключів** та **повторюваних ключів** у ваших словниках, що допомагає підтримувати контент чистим та ефективним.

---

## Оптимізації компілятора

Intlayer v8 включає новий шар кешування для Markdown та HTML компілятора. Це гарантує, що ідентичні рядки контенту з тією самою конфігурацією парсяться лише один раз, що значно зменшує витрати під час повторних рендерів або при використанні одного й того ж контенту в кількох місцях.

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // Витягувати вміст із компонентів у словники
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // Оптимізація імпортів: заміна useIntlayer на прямі імпорти словників
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> For vue / svelte you will need to install the appropriate compiler package:
>
> ```bash
> # Для Vue
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Для Svelte
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## Гнучкість: Уніфікований режим імпорту

Властивість булевого типу `live` була застаріла на користь більш всеосяжної властивості `importMode`. Це дозволяє явно визначати, як словники повинні завантажуватись: статично, динамічно або через live-синхронізацію.

### Режими

- **`static`** (За замовчуванням): Словник пакується під час збірки. Найкраще підходить для продуктивності.
- **`dynamic`**: Словник завантажується під час виконання (наприклад, через завантаження JSON або suspense).
- **`fetch`**: Словник отримується з CMS/Server під час виконання і синхронізується.

**Міграція:**

| Конфігурація v7 | Конфігурація v8                        |
| :-------------- | :------------------------------------- |
| `live: true`    | `importMode: 'fetch'`                  |
| `live: false`   | `importMode: 'static'` (або 'dynamic') |

Примітка: У Intlayer v8 властивість `importMode` була переміщена з конфігурації `build` до конфігурації `dictionary` у файлі `intlayer.config.ts`. Це дозволяє визначати режим імпорту за замовчуванням для всіх словників, одночасно даючи змогу перевизначати його для кожного словника окремо.

**Приклад глобальної конфігурації:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // Глобальне значення за замовчуванням
  },
  // ...
};
```

**Приклад словника:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // Перевизначає глобальну конфігурацію
    content: { ... }
}
```

---

## Керування розташуванням словників

v8 впроваджує властивість `location` для явного керування тим, де зберігаються словники та як вони синхронізуються. Це особливо корисно для гібридних робочих процесів, які поєднують локальні файли та віддалений CMS-контент.

### Параметри

- **`local`**: Словник існує лише локально. Він не буде відправлений у віддалений CMS.
- **`remote`**: Словник керується віддалено. Після розміщення в CMS він буде відокремлений від локальної версії. Віддалений словник буде витягнутий із CMS.
- **`local_and_remote`**: Словник існує в обох місцях. Локальні зміни відправляються, а віддалені зміни підтягуються (синхронізуються).

**Приклад:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // Тримати цей словник лише локально
    content: { ... }
}
```

---

## Розділення конфігурації системи

Intlayer v8 розділяє конфігурацію джерел контенту від внутрішніх системних та вихідних шляхів. Це звільняє властивість `content` від зайвих налаштувань і робить зрозумілим, які параметри призначені для керування користувачем, а які — керуються системою Intlayer.

Наступні властивості були переміщені з `content` до нової властивості `system` в `intlayer.config.ts`:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**Поведінка v7:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // Змішано з конфігурацією джерела
  },
};
```

**Поведінка v8:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // Чітко відокремлено
  },
};
```

---

## Відокремлення директорій контенту та коду

Intlayer v8 розділяє конфігурацію файлів визначення контенту та конфігурацію трансформації коду. Це дозволяє точніше налаштувати спостереження та сканування, покращуючи продуктивність збірки.

Раніше `contentDir` використовувався як для спостереження за файлами `.content.*`, так і для сканування коду на виклики `useIntlayer`. Тепер:

- **`contentDir`**: спеціально для ваших файлів оголошення контенту.
- **`codeDir`**: спеціально для коду вашого додатку, який потребує трансформації (наприклад, обрізка, оптимізація).

**Міграція:**

Якщо раніше ви вказували `contentDir`, Intlayer v8 також використовуватиме його за замовчуванням для `codeDir`, але виведе попередження. Вам слід явно визначити `codeDir` у вашій конфігурації.

**Поведінка v7:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // Використовується і для контенту, і для коду
  },
};
```

**Поведінка v8:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // Тут відстежуються лише файли src/content/*.content.* та @packages/design-system/dist/*.content.*
    codeDir: ["src", "@packages/design-system"], // Тут сканується тільки код для трансформацій та файли @packages/design-system/src/*.content.*
  },
};
```

---

## Фреймворк: Покращення для Svelte

Тепер Markdown і HTML-контент у Svelte автоматично перетворюються на HTML при серіалізації в рядок. Це значно полегшує використання синтаксису Svelte `{@html}`, оскільки тепер ви можете просто передати вузол контенту безпосередньо.

---

## Примітки до міграції з v7

### Зміни конфігурації

- **`live` property**: Властивість `live` у словниках застаріла. Використовуйте `importMode: 'fetch'` натомість.
- **`.set()` to `.use()`**: Метод `.set()` для перевизначень Markdown та HTML було перейменовано на `.use()` для кращої узгодженості з API інших фреймворків.
  /// **`contentDir` та `codeDir`**: `contentDir` тепер призначено виключно для файлів контенту. Додано нову властивість `codeDir` для трансформації коду. Якщо `codeDir` не встановлено, Intlayer використовуватиме `contentDir` як резервний варіант і виведе попередження.
  /// **Валідація схеми**: Щоб використовувати нову можливість `schema`, переконайтеся, що у вашому проєкті встановлено `zod`.
  ///
  /// ---
  ///
  /// ## Корисні посилання
  ///
  /// - [Довідник конфігурації](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/configuration.md)
- [Документація про файли контенту](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/dictionary/content_file.md)
- [Документація HTML-вмісту](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/dictionary/html.md)
- [Документація з Markdown-контенту](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/dictionary/markdown.md)
- [Документація про власні перезаписи URL](https://github.com/aymericzip/intlayer/blob/main/docs/docs/uk/custom_url_rewrites.md)
