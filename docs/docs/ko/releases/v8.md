---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: 새로운 Intlayer v8 - 무엇이 새로워졌나요?
description: Intlayer v8의 신규 기능을 확인하세요. 이번 릴리스는 developer experience 향상, schema validation을 통한 데이터 무결성 보장, 그리고 dictionary management에 대한 제어 강화에 중점을 둡니다.
keywords:
  - Intlayer
  - CMS
  - Developer Experience
  - Features
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# 새로운 Intlayer v8 - 무엇이 새로워졌나요?

Intlayer v8에 오신 것을 환영합니다! 이번 릴리스는 자동 콘텐츠 감지를 통한 developer experience 향상, schema validation으로 데이터 무결성 보장, 그리고 dictionary management에 대한 더 많은 제어 제공에 중점을 둡니다.

## 목차

<TOC levels={[2]} maxDepth={1} />

---

## HTML 콘텐츠 지원

Intlayer v8는 `html()` 함수를 도입하여 딕셔너리에 HTML과 유사한 콘텐츠를 삽입하고 런타임에 태그를 커스텀 컴포넌트로 매핑할 수 있게 합니다. 이는 단순한 Markdown 이상의 표현이 필요한 리치 텍스트나, 콘텐츠에 인터랙티브한 컴포넌트를 주입해야 할 때 이상적입니다.

**예제:**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html("Click <CustomLink>here</CustomLink> for more info"),
  },
};
```

**사용법:**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 직접 렌더링(표준 태그는 자동으로 동작합니다) */}
        {myRichText}

        {/* .use()로 커스터마이징 */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* 전역 커스터마이징을 위한 Provider 사용 */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 직접 렌더링(표준 태그는 자동으로 동작합니다) */}
        {myRichText}

        {/* .use()로 커스터마이징 */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* 전역 커스터마이징을 위한 Provider 사용 */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- 직접 렌더링 -->
        <component :is="myRichText" />

        <!-- .use()로 커스터마이징 -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 직접 렌더링 */}
        {myRichText}

        {/* .use()로 커스터마이징 */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 직접 렌더링 */}
        {myRichText}

        {/* .use()로 커스터마이징 */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- 직접 렌더링 -->
      {@html myRichText}

      <!-- .use()로 커스터마이징 -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

더 자세한 내용은 [HTML Content Documentation](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/dictionary/html.md)를 참조하세요.

---

## 사용자 정의 URL 재작성

Intlayer v8은 **사용자 정의 URL 재작성(Custom URL Rewrites)** 을 도입하여 표준 `/locale/path` 구조와 다른 로케일별 경로를 정의할 수 있게 합니다. 이는 로컬 SEO를 개선하고 영어가 아닌 사용자에게 보다 자연스러운 사용자 경험을 제공하는 강력한 기능입니다.

**v8의 주요 개선 사항:**

- **Framework Formatters**: 각 라우터에 맞는 관용적 패턴 구문을 제공하기 위해 새로운 `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite`, 및 `viteRewrite`가 추가되었습니다.
- **`useRewriteURL` Hook**: 라우터 네비게이션을 트리거하지 않고 주소 표시줄을 '예쁜' 지역화된 URL로 조용히 수정하는 새로운 클라이언트 사이드 훅입니다.
- **Automatic SEO Redirects**: 내장 프록시는 사용자가 수동으로 입력한 표준 경로(예: `/fr/about`)를 더 보기 좋은 지역화된 버전(예: `/fr/a-propos`)으로 자동으로 리디렉트합니다.

**예시 구성:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

이 기능은 Intlayer 프록시를 통해 **Next.js** 및 **Vite**에서 기본 제공되며, **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit**, **Solid Router** 같은 다른 라우터에도 쉽게 통합할 수 있습니다.

자세한 정보와 통합 가이드는 [Custom URL Rewrites Documentation](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/custom_url_rewrites.md)를 참조하세요.

---

## Markdown MDX & HTML: `.use()`

Intlayer v8은 리치 콘텐츠에 대한 API를 통합합니다. v7에서 Markdown에 사용되던 `.set()` 메서드는 Markdown과 HTML 전반에 걸쳐 일관된 경험을 제공하기 위해 [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx)로 이름이 변경되었습니다.

### 크로스-프레임워크 Markdown 파서

Intlayer는 이제 **MDX**를 지원하는 강력한 크로스-프레임워크 Markdown 파서를 통합합니다. 즉, HTML에서처럼 Markdown 콘텐츠 안에 컴포넌트를 직접 사용할 수 있습니다.

- **MDX 지원**: Markdown 내부에서 React/Vue/Svelte 컴포넌트를 사용하세요.
- **SSR 준비**: 파서는 서버 사이드 렌더링(SSR)에 최적화되어 초기 로딩이 빠르고 SEO 친화적인 리치 컨텐츠를 제공합니다.
- **일관된 API**: `.use()`를 사용해 Markdown/MDX 태그를 애플리케이션 컴포넌트에 매핑하세요.

**Markdown/MDX 예시:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // MDX-like syntax in Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

자세한 내용은 [Markdown 문서](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/dictionary/markdown.md)를 참고하세요.

---

### 향상된 삽입 값

v8에서는 삽입 값이 이제 문자열과 숫자 외에 **React 요소(또는 Vue 노드)** 를 허용할 수 있습니다. 이를 통해 삽입 템플릿에 풍부하고 상호작용 가능한 컴포넌트를 직접 주입할 수 있습니다.

Intlayer는 이제 삽입(insertion) 내의 중첩된 React 및 Preact 노드를 안정적으로 처리하여 복잡한 UI 구조가 보존되고 올바르게 렌더링되도록 합니다.

**예제:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 숫자
          // 또는
          name: "John", // 문자열
          // 또는
          name: <span>John</span>, // React 요소
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 숫자
          // 또는
          name: "John", // 문자열
          // 또는
          name: <span>John</span>, // React 요소
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // 또는
            name: 'John',
            // 또는
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 숫자
          // 또는
          name: "John", // 문자열
          // 또는
          name: <span>John</span>, // Preact 요소
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 숫자
          // 또는
          name: "John", // 문자열
          // 또는
          name: <span>John</span>, // Solid 요소
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // 숫자
        // 또는
        name: "John", // 문자열
      })}
    </div>
    ```

  </Tab>
</Tabs>

## 현지화: 새로운 `useIntl` 훅

새로운 `useIntl()` 훅이 React, Next.js 및 Vue에서 사용할 수 있게 되었습니다. 이 훅은 현재 언어에 바인딩된 `Intl` 객체를 제공하여, 로케일을 수동으로 전달할 필요 없이 숫자, 날짜 등 형식을 자동으로 현재 언어에 맞춰 처리합니다.

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## 콘텐츠 스키마 검증

Intlayer v8에서는 딕셔너리에 대한 스키마 검증을 도입합니다. 이제 Zod를 사용해 구성 파일에 재사용 가능한 검증 스키마를 정의하고 이를 콘텐츠 파일에 적용할 수 있습니다. 이를 통해 콘텐츠가 항상 예상된 구조를 따르도록 보장하여 빌드 시점에 오류를 포착할 수 있습니다.

### 1. 스키마 정의

`intlayer.config.ts`에서 스키마를 정의하세요:

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. 딕셔너리에 스키마 적용

딕셔너리 정의에서 스키마 키를 참조하세요:

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // 스키마 키
  content: {
    title: "About Our Company - Learn More About Us",
    description: "Discover our company's mission, values, and team.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

콘텐츠가 스키마와 일치하지 않으면(예: title이 너무 짧은 경우) 빌드 프로세스가 오류를 발생시킵니다.

---

### 향상된 자동 콘텐츠 감지

v8에서 Intlayer는 콘텐츠 문자열에서 Markdown 문법, HTML 태그 및 변수 삽입을 지능적으로 감지합니다. 이는 `md()`, `html()`, 또는 `insert()`와 같은 헬퍼 함수를 종종 생략할 수 있음을 의미합니다.

이 동작은 기본적으로 활성화되어 있습니다. 이제 이 감지 기능을 전역(`intlayer.config.ts`) 또는 dictionary별로 세부 조정할 수 있습니다.

#### 세부 제어

특정 유형의 변환을 활성화하거나 비활성화할 수 있습니다:

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (기본값)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // 자동 insertion 감지 비활성화
    },
  },
};
```

**v7 동작 (수동 래핑):**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**v8 동작 (자동 감지):**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // dictionary 정의에서 또는 전역적으로 intlayer.config.ts에서 설정할 수도 있습니다
  content: {
    myMarkdown: "## Hello World", // 자동으로 Markdown으로 감지됩니다
    myHTML: "<p>Hello World</p>", // 자동으로 HTML로 감지됩니다
    myInsertion: "Hi {{name}}", // 자동으로 Insertion으로 감지됩니다
  },
};
```

기본 JSON 결과는 동일하게 유지되며 렌더링에 필요한 풍부한 타입 정보를 보존합니다:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hello World"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hello World</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## 도구: VSCode 확장 기능 향상

Intlayer VSCode 확장 기능은 v8에서 국제화 워크플로우를 간소화하기 위해 주요 업데이트를 받았습니다:

- **시작 시간**: 프로젝트를 열 때의 성능 개선.
- **캐싱**: 거의 즉시 검증 및 자동완성을 제공하는 향상된 캐싱 레이어.
- **사용되지 않는 키 및 중복 키 감지**: 사전 전체에서 **사용되지 않는 키**와 **중복 키**를 자동으로 감지하는 새 기능으로, 콘텐츠를 깔끔하고 효율적으로 유지하는 데 도움을 줍니다.

---

## 컴파일러 최적화

Intlayer v8에는 Markdown 및 HTML 컴파일러를 위한 새로운 캐싱 레이어가 포함되어 있습니다. 이는 동일한 설정을 가진 동일한 콘텐츠 문자열을 한 번만 파싱하도록 하여, 재렌더링 시나 동일한 콘텐츠를 여러 곳에서 사용할 때 발생하는 오버헤드를 크게 줄여줍니다.

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // 컴포넌트에서 딕셔너리로 콘텐츠 추출
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // useIntlayer를 직접 dictionary import로 대체하여 임포트를 최적화합니다
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Vue / Svelte의 경우 적절한 컴파일러 패키지를 설치해야 합니다:
>
> ```bash
> # Vue의 경우
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Svelte의 경우
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## 유연성: 통합된 Import 모드

`live` boolean 속성은 더 포괄적인 `importMode` 속성으로 대체(deprecated)되었습니다. 이를 통해 딕셔너리를 정적(static), 동적(dynamic), 또는 라이브 동기화 방식으로 어떻게 로드할지 명시적으로 정의할 수 있습니다.

### 모드

- **`static`** (기본): 딕셔너리가 빌드 시 번들에 포함됩니다. 성능에 가장 적합합니다.
- **`dynamic`**: 런타임에 딕셔너리를 로드합니다(예: JSON fetch 또는 suspense).
- **`fetch`**: 런타임에 CMS/서버에서 딕셔너리를 가져와 동기화합니다.

**마이그레이션:**

| v7 구성       | v8 구성                                 |
| :------------ | :-------------------------------------- |
| `live: true`  | `importMode: 'fetch'`                   |
| `live: false` | `importMode: 'static'` (또는 'dynamic') |

참고: Intlayer v8에서는 `importMode` 속성이 `intlayer.config.ts`의 `build` 구성에서 `dictionary` 구성으로 이동되었습니다. 이를 통해 모든 사전에 대한 기본 import 모드를 정의하면서도 각 사전별로 이를 재정의할 수 있습니다.

**전역 구성 예시:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // 전역 기본값
  },
  // ...
};
```

**사전 예시:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // 전역 설정을 재정의함
    content: { ... }
}
```

---

## 사전 위치 제어

v8에서는 사전이 위치하는 곳과 동기화 방식을 명시적으로 관리할 수 있도록 `location` 속성이 도입되었습니다. 이는 로컬 파일과 원격 CMS 콘텐츠를 함께 사용하는 하이브리드 워크플로에 특히 유용합니다.

### 옵션

- **`local`**: 사전은 로컬에만 존재합니다. 원격 CMS로 푸시되지 않습니다.
- **`remote`**: 사전은 원격에서 관리됩니다. CMS에 푸시된 후 로컬 사전과 분리(detached)됩니다. 원격 사전은 CMS에서 pull 됩니다.
- **`local_and_remote`**: 사전은 양쪽 모두에 존재합니다. 로컬 변경사항은 푸시되고 원격 변경사항은 pull 되어 동기화됩니다.

**예제:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // 이 딕셔너리를 로컬 전용으로 유지합니다
    content: { ... }
}
```

---

## 시스템 구성 분리

Intlayer v8은 콘텐츠 소스 구성과 내부 시스템 및 출력 경로 구성을 분리합니다. 이는 `content` 속성을 정리하고 어떤 설정이 사용자 관리용인지, 어떤 설정이 Intlayer 시스템에서 관리하는지 명확히 합니다.

다음 속성들은 `content`에서 `intlayer.config.ts`의 새 `system` 속성으로 이동되었습니다:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**v7 동작:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // 소스 구성과 혼합됨
  },
};
```

**v8 동작:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // 명확하게 분리됨
  },
};
```

---

## 콘텐츠 및 코드 디렉토리 분리

Intlayer v8는 콘텐츠 정의 파일에 대한 설정을 코드 변환 설정과 분리합니다. 이를 통해 watching과 scanning을 보다 정확하게 수행할 수 있어 빌드 성능이 향상됩니다.

이전에는 `contentDir`가 `.content.*` 파일의 감시와 `useIntlayer` 호출을 위한 코드 스캔에 모두 사용되었습니다. 이제는:

- **`contentDir`**: 콘텐츠 선언 파일을 위한 전용 설정입니다.
- **`codeDir`**: 변환(예: pruning, optimization)을 필요로 하는 애플리케이션 코드 전용입니다.

**마이그레이션:**

이전에 `contentDir`를 설정한 경우, Intlayer v8은 이를 `codeDir`의 기본값으로 사용하지만 경고를 출력합니다. 구성에서 `codeDir`를 명시적으로 정의해야 합니다.

**v7 동작:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // 콘텐츠와 코드 모두에 사용됨
  },
};
```

**v8 동작:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // 여기서는 src/content/*.content.* 파일과 @packages/design-system/dist/*.content.* 파일만 감시합니다
    codeDir: ["src", "@packages/design-system"], // 여기서는 코드 변환을 위해 코드만 스캔하며 @packages/design-system/src/*.content.* 파일을 스캔합니다
  },
};
```

---

## 프레임워크: Svelte 개선사항

Svelte에서의 Markdown 및 HTML 콘텐츠는 이제 문자열화될 때 자동으로 HTML로 파싱됩니다. 이로 인해 Svelte의 `{@html}` 구문과 함께 사용하기가 훨씬 쉬워졌으며, 이제 콘텐츠 노드를 직접 전달하기만 하면 됩니다.

---

## v7에서의 마이그레이션 노트

### 구성 변경사항

- **`live` 속성**: 딕셔너리에서의 `live` 속성은 더 이상 권장되지 않습니다. 대신 `importMode: 'fetch'`를 사용하세요.
- **`.set()`에서 `.use()`로**: Markdown 및 HTML 오버라이드에서 사용되던 `.set()` 메서드는 다른 프레임워크 API와의 일관성을 위해 `.use()`로 이름이 변경되었습니다.
- **`contentDir` and `codeDir`**: `contentDir`는 이제 콘텐츠 파일 전용입니다. 코드 변환을 위한 새로운 `codeDir` 속성이 추가되었습니다. `codeDir`가 설정되어 있지 않으면 Intlayer는 `contentDir`로 폴백(fallback)하고 경고를 기록합니다.
- **스키마 검증**: 새로운 `schema` 기능을 사용하려면 프로젝트에 `zod`가 설치되어 있는지 확인하세요.

---

## 유용한 링크

- [구성 참조](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/configuration.md)
- [콘텐츠 파일 문서](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/dictionary/content_file.md)
- [HTML 콘텐츠 문서](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/dictionary/html.md)
- [Markdown 콘텐츠 문서](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/dictionary/markdown.md)
- [사용자 정의 URL 재작성 문서](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ko/custom_url_rewrites.md)
