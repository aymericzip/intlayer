---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: Neues Intlayer v8 - Was ist neu?
description: Entdecken Sie die Neuerungen in Intlayer v8. Bedeutende Verbesserungen in der Developer Experience, der Inhaltsvalidierung und der Verwaltung von Dictionaries.
keywords:
  - Intlayer
  - CMS
  - Developer Experience
  - Funktionen
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# Neues Intlayer v8 - Was ist neu?

Willkommen bei Intlayer v8! Diese Version konzentriert sich darauf, die Developer Experience durch automatische Inhaltserkennung zu verbessern, die Datenintegrität mittels Schema-Validierung sicherzustellen und mehr Kontrolle über die Verwaltung von Dictionaries zu bieten.

## Inhaltsverzeichnis

<TOC levels={[2]} maxDepth={1} />

---

## Unterstützung für HTML-Inhalte

Intlayer v8 führt die Funktion `html()` ein, mit der du HTML-ähnlichen Inhalt in deinen Dictionaries einbetten und Tags zur Laufzeit auf benutzerdefinierte Komponenten abbilden kannst. Das ist ideal für Rich-Text, der mehr als nur Markdown erfordert, oder wenn du interaktive Komponenten in deinen Content einfügen musst.

Beispiel:

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html(
      "Klicke <CustomLink>hier</CustomLink> für weitere Informationen"
    ),
  },
};
```

Verwendung:

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Direkte Darstellung (Standard-Tags funktionieren automatisch) */}
        {myRichText}

        {/* Anpassung mit .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Verwendung eines Providers für globale Anpassungen */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Direkte Darstellung (Standard-Tags funktionieren automatisch) */}
        {myRichText}

        {/* Anpassung mit .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Verwendung eines Providers für globale Anpassungen */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- Direkte Darstellung -->
        <component :is="myRichText" />

        <!-- Anpassen mit .use() -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Direkte Darstellung */}
        {myRichText}

        {/* Anpassen mit .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Direkte Darstellung */}
        {myRichText}

        {/* Anpassung mit .use() */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- Direkte Darstellung -->
      {@html myRichText}

      <!-- Anpassung mit .use() -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Für weitere Details siehe die [Dokumentation zu HTML-Inhalten](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/dictionary/html.md).

---

## Benutzerdefinierte URL-Rewrites

Intlayer v8 führt Unterstützung für **benutzerdefinierte URL-Rewrites** ein, mit denen du locale-spezifische Pfade definieren kannst, die von der Standardstruktur `/locale/path` abweichen. Dies ist eine leistungsfähige Funktion zur Verbesserung der lokalen SEO und zur Bereitstellung einer natürlicheren Benutzererfahrung für nicht-englischsprachige Nutzer.

**Wesentliche Verbesserungen in v8:**

- **Framework-Formatter**: Neue `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite` und `viteRewrite`, um für jeden Router eine idiomatische Mustersyntax bereitzustellen.
- **`useRewriteURL` Hook**: Ein neues clientseitiges Hook, das die Adressleiste stillschweigend zur "schönen" lokalisierten URL korrigiert, ohne Router-Navigationen auszulösen.
- **Automatische SEO-Weiterleitungen**: Eingebaute Proxies leiten Benutzer nun automatisch von manuell eingegebenen kanonischen Pfaden (z. B. `/fr/about`) zu ihren ansprechenderen lokalisierten Versionen (z. B. `/fr/a-propos`) weiter.

**Beispielkonfiguration:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

Diese Funktion wird von Haus aus in **Next.js** und **Vite** über die Intlayer-Proxies unterstützt und lässt sich problemlos in andere Router wie **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit** und **Solid Router** integrieren.

Weitere Informationen und Integrationsanleitungen finden Sie in der [Dokumentation zu benutzerdefinierten URL-Rewrites](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/custom_url_rewrites.md).

---

## Markdown MDX & HTML: `.use()`

Intlayer v8 vereinheitlicht die API für Rich Content. Die `.set()`-Methode (in v7 für Markdown verwendet) wurde in [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx) umbenannt, um eine konsistente Erfahrung sowohl für Markdown als auch für HTML zu bieten.

### Framework-übergreifender Markdown-Parser

Intlayer integriert jetzt einen leistungsstarken, frameworkübergreifenden Markdown-Parser, der **MDX** unterstützt. Das bedeutet, dass Sie Komponenten direkt in Ihrem Markdown-Inhalt verwenden können, genau wie in HTML.

- **MDX-Unterstützung**: Verwenden Sie React/Vue/Svelte-Komponenten innerhalb Ihres Markdown-Inhalts.
- **SSR-bereit**: Der Parser ist für Server-Side Rendering (SSR) optimiert und sorgt für schnelle Erstladezeiten sowie SEO-freundliche, reichhaltige Inhalte.
- **Konsistente API**: Verwenden Sie `.use()`, um Markdown/MDX-Tags auf Ihre Anwendungs-Komponenten abzubilden.

**Beispiel mit Markdown/MDX:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // MDX-like syntax in Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Weitere Informationen findest du in der [Markdown-Dokumentation](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/dictionary/markdown.md).

---

### Erweiterte Insertion-Werte

In v8 können Insertion-Werte jetzt neben Strings und Zahlen auch **React-Elemente (oder Vue-Knoten)** akzeptieren. Dadurch kannst du reichhaltige, interaktive Komponenten direkt in deine Insertionsvorlagen einfügen.

Intlayer unterstützt jetzt robust verschachtelte React- und Preact-Knoten innerhalb von Insertions und stellt sicher, dass komplexe UI-Strukturen erhalten bleiben und korrekt gerendert werden.

**Beispiel:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hallo {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // Zahl (number)
          // oder
          name: "John", // Zeichenkette (string)
          // oder
          name: <span>John</span>, // React-Element
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // Zahl
          // oder
          name: "John", // Zeichenkette
          // oder
          name: <span>John</span>, // React-Element
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // oder
            name: 'John',
            // oder
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // Zahl
          // oder
          name: "John", // String
          // oder
          name: <span>John</span>, // Preact-Element
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // Zahl
          // oder
          name: "John", // String
          // oder
          name: <span>John</span>, // Solid-Element
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // Zahl
        // oder
        name: "John", // Zeichenkette
      })}
    </div>
    ```

  </Tab>
</Tabs>

## Lokalisierung: neuer `useIntl` Hook

Ein neuer `useIntl()` Hook ist jetzt in React, Next.js und Vue verfügbar. Er stellt ein an die Locale gebundenes `Intl`-Objekt bereit, das automatisch die aktuelle Sprache für die Formatierung von Zahlen, Daten und mehr verwendet, ohne dass die Locale manuell übergeben werden muss.

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## Content-Schema-Validierung

Intlayer v8 führt eine Schema-Validierung für Dictionaries ein. Sie können jetzt wiederverwendbare Validierungsschemas in Ihrer Konfiguration mit Zod definieren und auf Ihre Content-Dateien anwenden. Das stellt sicher, dass Ihr Inhalt stets der erwarteten Struktur entspricht und Fehler bereits zur Build-Zeit erkannt werden.

### 1. Schemata definieren

Definieren Sie Ihre Schemata in `intlayer.config.ts`:

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. Schemata auf Dictionaries anwenden

Verweisen Sie in Ihrer Dictionary-Definition auf den Schema-Schlüssel:

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- Verweist auf das Schema
  content: {
    title: "Über unser Unternehmen – Erfahren Sie mehr über uns",
    description:
      "Erfahren Sie mehr über die Mission, die Werte und das Team unseres Unternehmens.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

Wenn der Inhalt nicht dem Schema entspricht (z. B. ist der Titel zu kurz), wird der Build-Prozess einen Fehler ausgeben.

---

### Verbesserte automatische Inhaltserkennung

In v8 erkennt Intlayer intelligent Markdown-Syntax, HTML-Tags und Variableinfügungen in Ihren Inhaltsstrings. Das bedeutet, dass Sie häufig Hilfsfunktionen wie `md()`, `html()` oder `insert()` weglassen können.

Dieses Verhalten ist standardmäßig aktiviert. Sie können diese Erkennung nun entweder global in Ihrer `intlayer.config.ts` oder pro Dictionary feinabstimmen.

#### Granulare Steuerung

Sie können bestimmte Arten von Transformationen aktivieren oder deaktivieren:

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (Standard)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // Automatische Erkennung von Insertion deaktivieren
    },
  },
};
```

**v7-Verhalten (manuelles Wrapping):**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**v8-Verhalten (Automatische Erkennung):**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // Kann auch in der Dictionary-Definition oder global in intlayer.config.ts gesetzt werden
  content: {
    myMarkdown: "## Hallo Welt", // Wird automatisch als Markdown erkannt
    myHTML: "<p>Hallo Welt</p>", // Wird automatisch als HTML erkannt
    myInsertion: "Hallo {{name}}", // Wird automatisch als Insertion erkannt
  },
};
```

Das zugrunde liegende JSON-Ergebnis bleibt gleich und bewahrt die umfangreichen Typinformationen, die für das Rendering benötigt werden:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hallo Welt"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hallo Welt</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## Tooling: Verbesserungen der VSCode-Erweiterung

Die Intlayer-VSCode-Erweiterung erhält in v8 umfassende Updates, um deinen Internationalisierungs-Workflow zu optimieren:

- **Startzeit**: Leistungsverbesserungen beim Öffnen eines Projekts.
- **Caching**: Verbesserte Cache-Schicht für nahezu sofortige Validierung und Autovervollständigung.
- **Erkennung ungenutzter und doppelter Schlüssel**: Neue Funktionen zur automatischen Erkennung von **ungenutzten Schlüsseln** und **doppelten Schlüsseln** in deinen dictionaries, die dir helfen, deinen Inhalt sauber und effizient zu halten.

---

## Compiler-Optimierungen

Intlayer v8 enthält eine neue Caching-Schicht für den Markdown- und HTML-Compiler. Diese stellt sicher, dass identische Inhaltsstrings mit derselben Konfiguration nur einmal geparst werden, was den Overhead bei erneuten Renderings oder bei Verwendung desselben Inhalts an mehreren Stellen deutlich reduziert.

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // Inhalt aus Komponenten in Wörterbücher extrahieren
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // Optimiert Importe, indem useIntlayer durch direkte dictionary-Imports ersetzt wird
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Für Vue / Svelte müssen Sie das entsprechende Compiler-Paket installieren:
>
> ```bash
> # Für Vue
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Für Svelte
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## Flexibilität: Einheitlicher Import-Modus

Die boolesche Eigenschaft `live` wurde zugunsten der umfassenderen Eigenschaft `importMode` als veraltet markiert. Dadurch kann explizit definiert werden, wie Dictionaries geladen werden sollen: statisch, dynamisch oder via Live-Synchronisation.

### Modi

- **`static`** (Standard): Das Dictionary wird zur Build-Zeit gebündelt. Optimal für die Performance.
- **`dynamic`**: Das Dictionary wird zur Laufzeit geladen (z. B. via JSON-Fetch oder Suspense).
- **`fetch`**: Das Dictionary wird zur Laufzeit vom CMS/Server abgerufen und synchronisiert.

**Migration:**

| v7 Konfiguration | v8 Konfiguration                        |
| :--------------- | :-------------------------------------- |
| `live: true`     | `importMode: 'fetch'`                   |
| `live: false`    | `importMode: 'static'` (oder 'dynamic') |

Hinweis: In Intlayer v8 wurde die Eigenschaft `importMode` von der `build`-Konfiguration in die `dictionary`-Konfiguration in `intlayer.config.ts` verschoben. Dadurch kannst du einen Standard-Importmodus für alle deine Dictionaries definieren und ihn trotzdem für jedes Dictionary einzeln überschreiben.

**Beispiel für globale Konfiguration:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // Globaler Standard
  },
  // ...
};
```

**Beispiel für ein Dictionary:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // Überschreibt die globale Konfiguration
    content: { ... }
}
```

---

## Steuerung des Speicherorts von Dictionaries

v8 führt die Eigenschaft `location` ein, um explizit zu verwalten, wo Wörterbücher leben und wie sie synchronisiert werden. Dies ist besonders nützlich für hybride Workflows, die sowohl lokale Dateien als auch Inhalte aus einem Remote-CMS umfassen.

### Optionen

- **`local`**: Das Wörterbuch existiert nur lokal. Es wird nicht zum Remote-CMS gepusht.
- **`remote`**: Das Wörterbuch wird remote verwaltet. Sobald es ins CMS gepusht wurde, wird es vom lokalen getrennt. Das entfernte Wörterbuch wird aus dem CMS abgerufen.
- **`local_and_remote`**: Das Wörterbuch existiert an beiden Orten. Lokale Änderungen werden gepusht, und entfernte Änderungen werden gepullt (synchronisiert).

**Beispiel:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // Dieses Wörterbuch nur lokal belassen
    content: { ... }
}
```

---

## Trennung der Systemkonfiguration

Intlayer v8 trennt die Konfiguration der Inhaltsquellen von internen System- und Ausgabe-Pfaden. Dadurch wird die `content`-Eigenschaft entschlackt und es wird deutlicher, welche Einstellungen für die Benutzerverwaltung vorgesehen sind und welche vom Intlayer-System verwaltet werden.

Die folgenden Eigenschaften wurden von `content` in eine neue `system`-Eigenschaft in `intlayer.config.ts` verschoben:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**Verhalten in v7:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // Mit der Quellkonfiguration vermischt
  },
};
```

**Verhalten in v8:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // Deutlich getrennt
  },
};
```

---

## Trennung von Content- und Code-Verzeichnissen

Intlayer v8 trennt die Konfiguration für Content-Definitionsdateien von der Konfiguration für Code-Transformation. Dadurch sind präziseres Watching und Scanning möglich, was die Build-Performance verbessert.

Früher wurde `contentDir` sowohl zum Überwachen von `.content.*`-Dateien als auch zum Scannen des Codes nach `useIntlayer`-Aufrufen verwendet. Jetzt:

- **`contentDir`**: Speziell für Ihre Content-Definitionsdateien.
- **`codeDir`**: Speziell für Ihren Anwendungs-Code, der transformiert werden muss (z. B. pruning, optimization).

**Migration:**

Wenn Sie zuvor `contentDir` gesetzt hatten, verwendet Intlayer v8 es standardmäßig auch als `codeDir`, gibt jedoch eine Warnung aus. Sie sollten `codeDir` explizit in Ihrer Konfiguration definieren.

**v7-Verhalten:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // Wird sowohl für Content als auch für Code verwendet
  },
};
```

**v8-Verhalten:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // Überwacht hier nur src/content/*.content.*-Dateien und @packages/design-system/dist/*.content.*-Dateien
    codeDir: ["src", "@packages/design-system"], // Scannt hier nur den Code für Transformationen und @packages/design-system/src/*.content.*-Dateien
  },
};
```

---

## Framework: Verbesserungen für Svelte

Markdown- und HTML-Inhalte in Svelte werden jetzt beim Serialisieren (stringified) automatisch in HTML geparst. Das macht die Verwendung mit Sveltes `{@html}`-Syntax deutlich einfacher, da du nun einfach den Content-Node direkt übergeben kannst.

---

## Hinweise zur Migration von v7

### Konfigurationsänderungen

- **`live` property**: Die `live`-Eigenschaft in Dictionaries ist veraltet. Verwende stattdessen `importMode: 'fetch'`.
- **`.set()` zu `.use()`**: Die `.set()`-Methode für Markdown- und HTML-Overrides wurde in `.use()` umbenannt, um besser mit den APIs anderer Frameworks konsistent zu sein.
- **`contentDir` und `codeDir`**: `contentDir` ist jetzt speziell für Inhaltsdateien. Eine neue Eigenschaft `codeDir` wurde für Code-Transformationen hinzugefügt. Wenn `codeDir` nicht gesetzt ist, fällt Intlayer auf `contentDir` zurück und protokolliert eine Warnung.
- **Schema-Validierung**: Um das neue `schema`-Feature zu verwenden, stellen Sie sicher, dass `zod` in Ihrem Projekt installiert ist.

---

## Nützliche Links

- [Konfigurationsreferenz](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/configuration.md)
- [Dokumentation zu Inhaltsdateien](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/dictionary/content_file.md)
- [Dokumentation zu HTML-Inhalten](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/dictionary/html.md)
- [Dokumentation zu Markdown-Inhalten](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/dictionary/markdown.md)
- [Dokumentation zu benutzerdefinierten URL-Umschreibungen](https://github.com/aymericzip/intlayer/blob/main/docs/docs/de/custom_url_rewrites.md)
