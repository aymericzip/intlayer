---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: Nuevo Intlayer v8 - ¿Qué hay de nuevo?
description: Descubre qué hay de nuevo en Intlayer v8. Mejoras importantes en la experiencia del desarrollador, en la validación de contenido y en la gestión de diccionarios.
keywords:
  - Intlayer
  - CMS
  - Experiencia del desarrollador
  - Características
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# Nuevo Intlayer v8 - ¿Qué hay de nuevo?

¡Bienvenido a Intlayer v8! Esta versión se centra en mejorar la experiencia del desarrollador con detección automática de contenido, garantizar la integridad de los datos mediante validación de esquemas y ofrecer un mayor control sobre la gestión de diccionarios.

## Table of contents

<TOC levels={[2]} maxDepth={1} />

---

## Soporte de contenido HTML

Intlayer v8 introduce la función `html()`, que te permite incrustar contenido tipo HTML en tus diccionarios y mapear etiquetas a componentes personalizados en tiempo de ejecución. Esto es ideal para texto enriquecido que requiere más que Markdown, o cuando necesitas inyectar componentes interactivos en tu contenido.

**Ejemplo:**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html(
      "Haz clic <CustomLink>aquí</CustomLink> para más información"
    ),
  },
};
```

**Uso:**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Renderizado directo (las etiquetas estándar funcionan automáticamente) */}
        {myRichText}

        {/* Personalización con .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Uso de un provider para la personalización global */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Renderizado directo (las etiquetas estándar funcionan automáticamente) */}
        {myRichText}

        {/* Personalización con .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Usando un proveedor para personalización global */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- Renderizado directo -->
        <component :is="myRichText" />

        <!-- Personalizando con .use() -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Renderizado directo */}
        {myRichText}

        {/* Personalizando con .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Renderizado directo */}
        {myRichText}

        {/* Personalización con .use() */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- Renderizado directo -->
      {@html myRichText}

      <!-- Personalización con .use() -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Para más detalles, consulte la [Documentación de contenido HTML](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/dictionary/html.md).

---

## Reescrituras de URL personalizadas

Intlayer v8 introduce soporte para **Reescrituras de URL personalizadas**, que te permite definir rutas específicas por locale que difieren de la estructura estándar `/locale/path`. Esta es una funcionalidad potente para mejorar el SEO local y ofrecer una experiencia de usuario más natural para usuarios que no hablan inglés.

**Mejoras clave en v8:**

- **Formateadores por framework**: Nuevos `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite` y `viteRewrite` para proporcionar una sintaxis de patrones idiomática para cada router.
- **`useRewriteURL` Hook**: Un nuevo hook del lado del cliente que corrige silenciosamente la barra de direcciones a la URL localizada "bonita" sin provocar navegaciones del router.
- **Redirecciones SEO automáticas**: Los proxies integrados ahora redirigen automáticamente a los usuarios desde rutas canónicas escritas manualmente (p. ej., `/fr/about`) a sus versiones localizadas más "bonitas" (p. ej., `/fr/a-propos`).

**Ejemplo de configuración:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

Esta característica está soportada de serie en **Next.js** y **Vite** a través de los proxies de Intlayer, y puede integrarse fácilmente en otros enrutadores como **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit** y **Solid Router**.

Para más información y guías de integración, consulta la [Documentación de Reescrituras de URL Personalizadas](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/custom_url_rewrites.md).

---

## Markdown MDX y HTML: `.use()`

Intlayer v8 unifica la API para contenido enriquecido. El método `.set()` (usado en la v7 para Markdown) ha sido renombrado a [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx) para proporcionar una experiencia consistente tanto en Markdown como en HTML.

### Analizador Markdown cross-framework

Intlayer ahora integra un potente analizador de Markdown compatible con múltiples frameworks que admite **MDX**. Esto significa que puedes usar componentes directamente dentro de tu contenido Markdown, igual que en HTML.

- **MDX Support**: Usa componentes React/Vue/Svelte dentro de tu Markdown.
- **SSR Ready**: El analizador está optimizado para Server-Side Rendering (SSR), asegurando cargas iniciales rápidas y contenido enriquecido amigable para SEO.
- **Consistent API**: Usa `.use()` para mapear etiquetas Markdown/MDX a los componentes de tu aplicación.

**Ejemplo con Markdown/MDX:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // Sintaxis tipo MDX en Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Consulte la [Documentación de Markdown](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/dictionary/markdown.md) para más información.

---

### Valores de Inserción Mejorados

En la v8, los valores de inserción ahora pueden **aceptar elementos de React (o nodos de Vue)** además de cadenas y números. Esto te permite inyectar componentes enriquecidos e interactivos directamente en tus plantillas de inserción.

Intlayer ahora maneja de forma robusta nodos anidados de React y Preact dentro de las inserciones, asegurando que las estructuras de interfaz de usuario (UI) complejas se conserven y se rendericen correctamente.

**Ejemplo:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // número
          // o
          name: "John", // cadena
          // o
          name: <span>John</span>, // elemento React
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // número
          // o
          name: "John", // cadena
          // o
          name: <span>John</span>, // elemento de React
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2, // número
            // o
            name: 'John', // cadena
            // o
            name: h('span', 'John'), // elemento de Vue
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // número
          // o
          name: "John", // cadena
          // o
          name: <span>John</span>, // elemento Preact
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // número
          // o
          name: "John", // cadena
          // o
          name: <span>John</span>, // elemento de Solid
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // número
        // o
        name: "John", // cadena
      })}
    </div>
    ```

  </Tab>
</Tabs>

## Localización: nuevo hook `useIntl`

Un nuevo hook `useIntl()` ya está disponible en React, Next.js y Vue. Proporciona un objeto `Intl` vinculado al locale que utiliza automáticamente el idioma actual para formatear números, fechas y más, sin necesidad de pasar manualmente el locale.

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## Validación de Esquemas de Contenido

Intlayer v8 introduce la validación de esquemas para diccionarios. Ahora puedes definir esquemas de validación reutilizables en tu configuración usando Zod y aplicarlos a tus archivos de contenido. Esto asegura que tu contenido siempre cumpla con la estructura esperada, detectando errores en tiempo de compilación.

### 1. Definir Esquemas

Define tus esquemas en `intlayer.config.ts`:

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. Aplicar Esquemas a Diccionarios

Referencia la clave del esquema en la definición de tu diccionario:

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- referencia al esquema
  content: {
    title: "About Our Company - Learn More About Us",
    description: "Discover our company's mission, values, and team.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

Si el contenido no coincide con el esquema (p. ej., si el title es demasiado corto), el proceso de compilación generará un error.

---

### Detección automática de contenido mejorada

En la v8, Intlayer detecta de forma inteligente la sintaxis Markdown, las etiquetas HTML y las inserciones de variables en tus cadenas de contenido. Esto significa que a menudo puedes omitir funciones auxiliares como `md()`, `html()` o `insert()`.

Este comportamiento está habilitado por defecto. Ahora puedes afinar esta detección ya sea de forma global en tu `intlayer.config.ts` o por diccionario.

#### Control granular

Puedes habilitar o deshabilitar tipos específicos de transformaciones:

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (predeterminado)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // Desactivar la detección automática de inserciones
    },
  },
};
```

**Comportamiento v7 (envoltura manual):**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**Comportamiento v8 (Detección automática):**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // También puede configurarse por la definición del diccionario o globalmente en intlayer.config.ts
  content: {
    myMarkdown: "## Hello World", // Detectado automáticamente como Markdown
    myHTML: "<p>Hello World</p>", // Detectado automáticamente como HTML
    myInsertion: "Hi {{name}}", // Detectado automáticamente como Insertion
  },
};
```

El resultado JSON subyacente permanece igual, conservando la rica información de tipo necesaria para el renderizado:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hello World"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hello World</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## Herramientas: Mejoras en la extensión de VSCode

La extensión de Intlayer para VSCode recibe actualizaciones importantes en la v8 para optimizar tu flujo de trabajo de internacionalización:

- **Tiempo de inicio**: Mejoras de rendimiento al abrir un proyecto.
- **Caché**: Capa de caché mejorada para validación y autocompletado casi instantáneos.
- **Detección de claves sin usar y duplicadas**: Nuevas funcionalidades para detectar automáticamente **claves sin usar** y **claves duplicadas** en tus diccionarios, ayudándote a mantener tu contenido limpio y eficiente.

---

## Optimizaciones del compilador

Intlayer v8 incluye una nueva capa de caché para el compilador de Markdown y HTML. Esto garantiza que las cadenas de contenido idénticas con la misma configuración se analicen solo una vez, reduciendo significativamente la sobrecarga durante los re-renderizados o cuando se utiliza el mismo contenido en múltiples lugares.

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // Extrae el contenido de los componentes en diccionarios
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // Optimiza las importaciones reemplazando useIntlayer por importaciones directas de diccionarios
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Para Vue / Svelte necesitarás instalar el paquete de compilador correspondiente:
>
> ```bash
> # Para Vue
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Para Svelte
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## Flexibilidad: Modo de Importación Unificado

La propiedad booleana `live` está obsoleta en favor de una propiedad más completa: `importMode`. Esto permite definir explícitamente cómo deben cargarse los diccionarios: de forma estática, dinámica o mediante sincronización en vivo.

### Modos

- **`static`** (Predeterminado): El diccionario se incluye en el bundle en tiempo de compilación. Mejor para el rendimiento.
- **`dynamic`**: El diccionario se carga en tiempo de ejecución (p. ej., mediante fetch de JSON o suspense).
- **`fetch`**: El diccionario se obtiene del CMS/servidor en tiempo de ejecución y se sincroniza.

**Migración:**

| Configuración v7 | Configuración v8                     |
| :--------------- | :----------------------------------- |
| `live: true`     | `importMode: 'fetch'`                |
| `live: false`    | `importMode: 'static'` (o 'dynamic') |

Nota: en Intlayer v8, la propiedad `importMode` se ha movido de la configuración `build` a la configuración `dictionary` en `intlayer.config.ts`. Esto te permite definir un modo de importación predeterminado para todos tus diccionarios, manteniendo la posibilidad de sobrescribirlo por diccionario.

**Ejemplo de configuración global:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // Predeterminado global
  },
  // ...
};
```

**Ejemplo de diccionario:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // Sobrescribe la configuración global
    content: { ... }
}
```

---

## Control de ubicación del diccionario

v8 introduce la propiedad `location` para gestionar explícitamente dónde residen los diccionarios y cómo se sincronizan. Esto es especialmente útil para flujos de trabajo híbridos que implican tanto archivos locales como contenido en un CMS remoto.

### Opciones

- **`local`**: El diccionario existe solo localmente. No se enviará (push) al CMS remoto.
- **`remote`**: El diccionario se gestiona de forma remota. Una vez enviado al CMS, se desvinculará del local. El diccionario remoto se extraerá (pull) desde el CMS.
- **`local_and_remote`**: El diccionario existe en ambos lugares. Los cambios locales se envían (push) y los cambios remotos se extraen (pull) (sincronizados).

**Ejemplo:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // Mantener este diccionario solo local
    content: { ... }
}
```

---

## Separación de la configuración del sistema

Intlayer v8 separa la configuración de las fuentes de contenido de las rutas internas del sistema y de salida. Esto despeja la propiedad `content` y deja claro qué ajustes están destinados a la gestión por el usuario frente a los que gestiona el sistema de Intlayer.

Las siguientes propiedades se han movido de `content` a una nueva propiedad `system` en `intlayer.config.ts`:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**Comportamiento en v7:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // Mezclado con la configuración de origen
  },
};
```

**Comportamiento en v8:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // Claramente separado
  },
};
```

---

## Separación de Directorios de Contenido y Código

Intlayer v8 separa la configuración para los archivos de definición de contenido de la configuración para la transformación de código. Esto permite una vigilancia y escaneo más precisos, mejorando el rendimiento de la compilación.

Anteriormente, `contentDir` se usaba tanto para vigilar archivos `.content.*` como para escanear el código en busca de llamadas a `useIntlayer`. Ahora:

- **`contentDir`**: Específicamente para tus archivos de declaración de contenido.
- **`codeDir`**: Específicamente para el código de tu aplicación que necesita transformación (p. ej., poda, optimización).

**Migración:**

Si anteriormente tenías `contentDir` configurado, Intlayer v8 lo usará también como valor predeterminado para `codeDir`, pero registrará una advertencia. Debes definir explícitamente `codeDir` en tu configuración.

**Comportamiento en v7:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // Usado tanto para contenido como para código
  },
};
```

**Comportamiento en v8:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // Solo vigila aquí los archivos src/content/*.content.* y los archivos @packages/design-system/dist/*.content.*
    codeDir: ["src", "@packages/design-system"], // Solo escanea para transformación de código aquí y los archivos @packages/design-system/src/*.content.*
  },
};
```

---

## Framework: Mejoras en Svelte

El contenido Markdown y HTML en Svelte ahora se convierte automáticamente a HTML al serializarse (stringified). Esto facilita mucho su uso con la sintaxis `{@html}` de Svelte, ya que ahora puedes simplemente pasar el nodo de contenido directamente.

---

## Notas de migración desde v7

### Cambios en la configuración

- **`live` property**: La propiedad `live` en los diccionarios está obsoleta. Usa `importMode: 'fetch'` en su lugar.
- **`.set()` to `.use()`**: El método `.set()` para los overrides de Markdown y HTML ha sido renombrado a `.use()` para mejorar la consistencia con otras APIs del framework.
- **`contentDir` and `codeDir`**: `contentDir` ahora es específicamente para archivos de contenido. Se ha añadido una nueva propiedad `codeDir` para la transformación de código. Si `codeDir` no está establecida, Intlayer hará fallback a `contentDir` y registrará una advertencia.
- **Validación de `schema`**: Para usar la nueva funcionalidad `schema`, asegúrate de tener `zod` instalado en tu proyecto.

---

## Enlaces útiles

- [Referencia de configuración](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/configuration.md)
- [Documentación de archivos de contenido](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/dictionary/content_file.md)
- [Documentación de contenido HTML](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/dictionary/html.md)
- [Documentación de contenido Markdown](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/dictionary/markdown.md)
- [Documentación de reescritura de URL personalizada](https://github.com/aymericzip/intlayer/blob/main/docs/docs/es/custom_url_rewrites.md)
