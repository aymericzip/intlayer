---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: Intlayer v8 の新機能
description: Intlayer v8 の新機能を紹介します。開発者体験、自動コンテンツ検出、スキーマ検証によるデータ整合性、辞書管理における主な改善点を解説します。
keywords:
  - Intlayer
  - CMS
  - Developer Experience
  - Features
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# Intlayer v8 の新機能

Intlayer v8 へようこそ！このリリースでは、自動コンテンツ検出による開発者体験の向上、スキーマ検証によるデータ整合性の確保、辞書管理に対するより細かい制御の提供に注力しています。

## 目次

<TOC levels={[2]} maxDepth={1} />

---

## HTML コンテンツのサポート

Intlayer v8 では `html()` 関数が導入され、辞書内に HTML のようなコンテンツを埋め込んだり、実行時にタグをカスタムコンポーネントにマップしたりできるようになりました。これは Markdown だけでは表現しきれないリッチテキストや、コンテンツ内にインタラクティブなコンポーネントを挿入する必要がある場合に最適です。

**例:**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html("詳細は<CustomLink>こちら</CustomLink>をご覧ください"),
  },
};
```

**使用方法:**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 直接レンダリング（標準タグは自動的に動作します） */}
        {myRichText}

        {/* .use() を使ったカスタマイズ */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* グローバルカスタマイズのためにプロバイダーを使用 */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 直接レンダリング（標準タグは自動的に動作します） */}
        {myRichText}

        {/* .use() を使ったカスタマイズ */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* グローバルカスタマイズのためのプロバイダーの使用 */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- 直接レンダリング -->
        <component :is="myRichText" />

        <!-- .use() を使ったカスタマイズ -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 直接レンダリング */}
        {myRichText}

        {/* .use() を使ったカスタマイズ */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* 直接レンダリング */}
        {myRichText}

        {/* .use() を使ったカスタマイズ */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- 直接レンダリング -->
      {@html myRichText}

      <!-- .use() を使ったカスタマイズ -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

詳細は[HTMLコンテンツのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/dictionary/html.md)を参照してください。

---

## カスタム URL リライト

Intlayer v8 は **カスタム URL リライト** を導入し、標準の `/locale/path` 構造と異なるロケール固有のパスを定義できるようになります。これはローカルSEOの改善や、英語以外のユーザーにとってより自然なユーザーエクスペリエンスを提供するための強力な機能です。

**v8 の主な強化点:**

- **Framework Formatters**: `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite`, `viteRewrite` を新たに追加し、各ルーターに対して慣用的なパターン構文を提供します。
- **`useRewriteURL` フック**：クライアントサイドの新しいフックで、ルーターのナビゲーションを発生させることなく、アドレスバーをより見栄えの良いローカライズされたURLに静かに修正します。
- **自動SEOリダイレクト**：組み込みのプロキシが、手で入力されたカノニカルパス（例：`/fr/about`）から、より見栄えの良いローカライズ版（例：`/fr/a-propos`）へ自動的にリダイレクトするようになりました。

**設定例:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite（Vue、Solid、Svelte）" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

この機能は Intlayer のプロキシを通じて **Next.js** と **Vite** でアウト・オブ・ザ・ボックスでサポートされており、**TanStack Router**、**React Router**、**Vue Router**、**SvelteKit**、**Solid Router** などの他のルーターにも簡単に統合できます。

詳細と統合ガイドについては、[カスタム URL リライトのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/custom_url_rewrites.md) を参照してください。

---

## Markdown MDX と HTML: `.use()`

Intlayer v8 はリッチコンテンツ向けの API を統一します。`.set()` メソッド（v7 で Markdown に使用されていたもの）は、Markdown と HTML の両方で一貫した体験を提供するために [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx) に改名されました。

### クロスフレームワークの Markdown パーサ

Intlayer は現在、**MDX** をサポートする強力なクロスフレームワークの Markdown パーサーを統合しています。これにより、HTML と同様に Markdown コンテンツ内でコンポーネントを直接使用できます。

- **MDX サポート**: Markdown 内で React/Vue/Svelte コンポーネントを使用できます。
- **SSR 対応**: パーサーはサーバーサイドレンダリング（SSR）に最適化されており、初回読み込みの高速化と SEO に適したリッチコンテンツを実現します。
- **一貫した API**: `.use()` を使って Markdown/MDX のタグをアプリケーションのコンポーネントにマッピングします。

**Markdown/MDX の例:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // Markdown 内で MDX ライクな構文
    myMarkdown: md("## ぜひご覧ください \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

詳細は[Markdownドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/dictionary/markdown.md)を参照してください。

---

### 拡張された挿入値

v8 では、挿入値は文字列や数値に加えて、**React 要素（または Vue ノード）**を受け取れるようになりました。これにより、リッチでインタラクティブなコンポーネントを挿入テンプレートに直接注入できます。

Intlayer は挿入内の入れ子になった React および Preact のノードを堅牢に処理するようになり、複雑な UI 構造が保持され正しくレンダリングされることを保証します。

**例:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 数値
          // または
          name: "John", // 文字列
          // または
          name: <span>John</span>, // React 要素
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 数値
          // または
          name: "John", // 文字列
          // または
          name: <span>John</span>, // React 要素
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // または
            name: 'John',
            // または
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 数値
          // または
          name: "John", // 文字列
          // または
          name: <span>John</span>, // Preact 要素
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // 数値
          // または
          name: "John", // 文字列
          // または
          name: <span>John</span>, // Solid 要素
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // 数値
        // または
        name: "John", // 文字列
      })}
    </div>
    ```

  </Tab>
</Tabs>

## ローカリゼーション: 新しい `useIntl` フック

React、Next.js、Vue で新しい `useIntl()` フックが利用可能になりました。これはロケールに紐づいた `Intl` オブジェクトを提供し、数値や日付などのフォーマットに現在の言語を自動的に使用するため、ロケールを手動で渡す必要がありません。

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## コンテンツスキーマ検証

Intlayer v8 では、辞書に対するスキーマ検証が導入されました。Zod を使って設定内に再利用可能なバリデーションスキーマを定義し、それをコンテンツファイルに適用できます。これにより、コンテンツが常に期待される構造に準拠していることが保証され、ビルド時にエラーを検出できます。

### 1. スキーマを定義する

`intlayer.config.ts` にスキーマを定義します：

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. スキーマを辞書に適用する

辞書定義でスキーマキーを参照します：

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- スキーマキーを参照
  content: {
    title: "About Our Company - Learn More About Us",
    description: "Discover our company's mission, values, and team.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

コンテンツがスキーマと一致しない場合（例：title が短すぎるなど）、ビルドプロセスでエラーが発生します。

---

### 強化された自動コンテンツ検出

v8 では、Intlayer がコンテンツ文字列内の Markdown 構文、HTML タグ、および変数挿入を自動的に検出します。これにより、`md()`、`html()`、`insert()` といったヘルパー関数を省略できることが多くなります。

この挙動はデフォルトで有効です。`intlayer.config.ts` のグローバル設定または各ディクショナリごとに、この検出を細かく調整できます。

#### 詳細な制御

特定の変換タイプを有効化または無効化できます：

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false（デフォルト）
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // 自動挿入検出を無効化
    },
  },
};
```

**v7 の挙動（手動でのラッピング）：**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**v8 の動作（自動検出）:**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // この設定は辞書定義または intlayer.config.ts のグローバル設定でも指定できます
  content: {
    myMarkdown: "## Hello World", // 自動的に Markdown と検出されます
    myHTML: "<p>Hello World</p>", // 自動的に HTML と検出されます
    myInsertion: "Hi {{name}}", // 自動的に Insertion と検出されます
  },
};
```

基になる JSON の結果は同じで、レンダリングに必要な豊富な型情報は保持されます:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hello World"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hello World</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## ツール: VSCode 拡張機能の強化

Intlayer の VSCode 拡張機能は v8 で大幅なアップデートを受け、国際化ワークフローを効率化します:

- **起動時間**: プロジェクトを開く際のパフォーマンスが改善されます。
- **キャッシュ**: ほぼ瞬時のバリデーションとオートコンプリートを実現する強化されたキャッシュ層。
- **未使用キー & 重複キー検出**: 新機能により、辞書全体で**未使用のキー**や**重複したキー**を自動検出し、コンテンツをクリーンで効率的に保つのに役立ちます。

---

## コンパイラの最適化

Intlayer v8 には Markdown と HTML コンパイラ向けの新しいキャッシング層が導入されました。これにより、同じ設定で同一のコンテンツ文字列は一度だけ解析されるため、再レンダリング時や複数箇所で同じコンテンツを使用する場合のオーバーヘッドが大幅に削減されます。

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // コンポーネントから辞書へコンテンツを抽出する
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // useIntlayer を直接辞書インポートに置き換えることでインポートを最適化
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Vue / Svelte の場合は、適切なコンパイラパッケージをインストールする必要があります：
>
> ```bash
> # Vue の場合
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Svelte の場合
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## 柔軟性：統一されたインポートモード

`live` ブールプロパティは、より包括的な `importMode` プロパティに置き換えられ、非推奨になりました。これにより、辞書をどのように読み込むか（静的、動的、またはライブ同期）を明示的に定義できるようになります。

### モード

- **`static`**（デフォルト）：辞書はビルド時にバンドルされます。パフォーマンスに最適です。
- **`dynamic`**：辞書はランタイムで読み込まれます（例：JSON フェッチや suspense 経由）。
- **`fetch`**：辞書はランタイムで CMS/サーバー から取得され、同期されます。

**移行:**

| v7 設定       | v8 設定                                    |
| :------------ | :----------------------------------------- |
| `live: true`  | `importMode: 'fetch'`                      |
| `live: false` | `importMode: 'static'`（または 'dynamic'） |

注: Intlayer v8 では、`importMode` プロパティは `intlayer.config.ts` の `build` 設定から `dictionary` 設定へ移動しました。これにより、すべての辞書に対するデフォルトの `importMode` を定義しつつ、各辞書ごとに上書きできるようになります。

**グローバル設定の例:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // グローバルのデフォルト
  },
  // ...
};
```

**辞書の例:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // グローバル設定を上書き
    content: { ... }
}
```

---

## 辞書の配置制御

v8では、dictionaryがどこに存在し、どのように同期されるかを明示的に管理するために`location`プロパティが導入されました。これはローカルファイルとリモートCMSのコンテンツを組み合わせたハイブリッドなワークフローで特に有用です。

### オプション

- **`local`**: dictionaryはローカルにのみ存在します。リモートCMSへはプッシュされません。
- **`remote`**: dictionaryはリモートで管理されます。一度CMSにプッシュされるとローカルのものと切り離されます。リモートのdictionaryはCMSからプルされます。
- **`local_and_remote`**: dictionaryは両方に存在します。ローカルの変更はプッシュされ、リモートの変更はプルされ（同期されます）。

**例:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // このdictionaryをローカル専用に保ちます
    content: { ... }
}
```

---

## システム構成の分離

Intlayer v8では、コンテンツソースの設定を内部システムおよび出力パスの設定から分離します。これにより `content` プロパティが整理され、ユーザーが管理する設定と Intlayer システムが管理する設定がどれかが明確になります。

次のプロパティは `content` から `intlayer.config.ts` の新しい `system` プロパティに移動されました:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**v7 の挙動:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // ソース設定と混在していました
  },
};
```

**v8 の挙動:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // 明確に分離されています
  },
};
```

---

## コンテンツとコードディレクトリの分離

Intlayer v8 は、コンテンツ定義ファイルの設定とコード変換の設定を分離します。これにより、監視とスキャンの対象をより正確に指定でき、ビルドパフォーマンスが向上します。

以前は、`.content.*` ファイルの監視と `useIntlayer` 呼び出しのためのコードスキャンの両方に `contentDir` が使われていました。現在は以下のように分かれています:

- **`contentDir`**: コンテンツ宣言ファイル専用です。
- **`codeDir`**: 変換が必要なアプリケーションコード専用です（例：トリミング、最適化）。

**移行:**

以前に `contentDir` を設定していた場合、Intlayer v8 はそれを `codeDir` のデフォルトとしても使用しますが、警告をログに出します。設定ファイルで `codeDir` を明示的に定義するべきです。

**v7 の動作:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // コンテンツおよびコードの両方で使用される
  },
};
```

**v8 の動作:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // ここでは src/content/*.content.* ファイルと @packages/design-system/dist/*.content.* ファイルのみを監視する
    codeDir: ["src", "@packages/design-system"], // ここではコード変換のためにのみスキャンを実行し、@packages/design-system/src/*.content.* ファイルを対象とする
  },
};
```

---

## フレームワーク: Svelte の改善

Svelte 内の Markdown および HTML コンテンツは、stringified（文字列化）される際に自動的に HTML として解析されるようになりました。これにより Svelte の `{@html}` 構文と組み合わせて使うのが格段に簡単になり、コンテンツノードをそのまま渡すだけで済みます。

---

## v7 からの移行ノート

### 設定の変更

- **`live` property**: 辞書内の `live` プロパティは非推奨になりました。代わりに `importMode: 'fetch'` を使用してください。
- **`.set()` to `.use()`**: Markdown と HTML のオーバーライドに使っていた `.set()` メソッドは、他のフレームワーク API と整合性を取るため `.use()` に名称が変更されました。
- **`contentDir` と `codeDir`**: `contentDir` はコンテンツファイル専用になりました。コード変換用に新しく `codeDir` プロパティが追加されました。`codeDir` が設定されていない場合、Intlayer は `contentDir` にフォールバックし、警告をログに出力します。
- **スキーマ検証**: 新しい `schema` 機能を使用するには、プロジェクトに `zod` がインストールされていることを確認してください。

---

## 参考リンク

- [設定リファレンス](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/configuration.md)
- [コンテンツファイルのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/dictionary/content_file.md)
- [HTMLコンテンツのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/dictionary/html.md)
- [Markdown コンテンツのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/dictionary/markdown.md)
- [カスタム URL 書き換えのドキュメント](https://github.com/aymericzip/intlayer/blob/main/docs/docs/ja/custom_url_rewrites.md)
