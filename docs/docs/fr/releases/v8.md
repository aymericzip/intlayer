---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: Intlayer v8 — Nouveautés
description: Découvrez les nouveautés d'Intlayer v8. Améliorations majeures de l'expérience développeur, validation du contenu et gestion des dictionnaires.
keywords:
  - Intlayer
  - CMS
  - Expérience développeur
  - Fonctionnalités
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# Intlayer v8 — Nouveautés

Bienvenue dans Intlayer v8 ! Cette version se concentre sur l'amélioration de l'expérience développeur grâce à la détection automatique de contenu, à l'assurance de l'intégrité des données via la validation de schéma, et à un meilleur contrôle de la gestion des dictionnaires.

## Table des matières

<TOC levels={[2]} maxDepth={1} />

---

## Prise en charge du contenu HTML

Intlayer v8 introduit la fonction `html()`, qui vous permet d'incorporer du contenu de type HTML dans vos dictionaries et d'associer des balises à des composants personnalisés à l'exécution. Cela est idéal pour du rich text nécessitant plus que du Markdown, ou lorsque vous devez injecter des composants interactifs dans votre contenu.

**Exemple :**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html(
      "Cliquez <CustomLink>ici</CustomLink> pour plus d'informations"
    ),
  },
};
```

**Utilisation :**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Rendu direct (les balises standard fonctionnent automatiquement) */}
        {myRichText}

        {/* Personnalisation avec .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Utilisation d'un provider pour personnalisation globale */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Rendu direct (les balises standard fonctionnent automatiquement) */}
        {myRichText}

        {/* Personnalisation avec .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* Utilisation d'un provider pour la personnalisation globale */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- Rendu direct -->
        <component :is="myRichText" />

        <!-- Personnalisation avec .use() -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Rendu direct */}
        {myRichText}

        {/* Personnalisation avec .use() */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* Rendu direct */}
        {myRichText}

        {/* Personnalisation avec .use() */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- Rendu direct -->
      {@html myRichText}

      <!-- Personnalisation avec .use() -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Pour plus de détails, consultez la [documentation sur le contenu HTML](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/dictionary/html.md).

---

## Réécritures d'URL personnalisées

Intlayer v8 introduit la prise en charge des **réécritures d'URL personnalisées**, vous permettant de définir des chemins spécifiques à une locale qui diffèrent de la structure standard `/locale/path`. C'est une fonctionnalité puissante pour améliorer le SEO local et offrir une expérience utilisateur plus naturelle aux utilisateurs non anglophones.

**Principales améliorations de la v8 :**

- **Formatters pour frameworks** : Nouveaux `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite` et `viteRewrite` pour fournir une syntaxe de pattern idiomatique adaptée à chaque routeur.
- **Hook `useRewriteURL`** : Un nouveau hook côté client qui corrige silencieusement la barre d'adresse vers l'URL localisée "esthétique" sans déclencher de navigation par le routeur.
- **Redirections SEO automatiques** : Les proxies intégrés redirigent désormais automatiquement les utilisateurs des chemins canoniques saisis manuellement (par ex. `/fr/about`) vers leurs versions localisées plus esthétiques (par ex. `/fr/a-propos`).

**Exemple de configuration :**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

Cette fonctionnalité est prise en charge nativement dans **Next.js** et **Vite** via les proxies Intlayer, et peut être facilement intégrée à d'autres routeurs comme **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit** et **Solid Router**.

Pour plus d'informations et des guides d'intégration, consultez la [documentation sur les réécritures d'URL personnalisées](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/custom_url_rewrites.md).

---

## Markdown MDX & HTML : `.use()`

Intlayer v8 unifie l'API pour le contenu riche. La méthode `.set()` (utilisée en v7 pour le Markdown) a été renommée en [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx) afin d'offrir une expérience cohérente tant pour Markdown que pour HTML.

### Parseur Markdown multi-framework

Intlayer intègre désormais un puissant analyseur Markdown multi-framework qui prend en charge **MDX**. Cela signifie que vous pouvez utiliser des composants directement dans votre contenu Markdown, comme en HTML.

- **Prise en charge de MDX** : Utilisez des composants React/Vue/Svelte dans votre Markdown.
- **Prêt pour le rendu côté serveur (SSR)** : L'analyseur est optimisé pour le rendu côté serveur (SSR), garantissant des temps de chargement initiaux rapides et un contenu enrichi favorable au SEO.
- **API cohérente** : Utilisez `.use()` pour mapper les balises Markdown/MDX aux composants de votre application.

**Exemple avec Markdown/MDX :**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // MDX-like syntax in Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

Voir la [documentation Markdown](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/dictionary/markdown.md) pour plus d'informations.

---

### Valeurs d'insertion améliorées

Dans la v8, les valeurs d'insertion peuvent désormais **accepter des éléments React (ou des nœuds Vue)** en plus des chaînes et des nombres. Cela vous permet d'injecter des composants riches et interactifs directement dans vos modèles d'insertion.

Intlayer gère désormais de manière robuste les nœuds React et Preact imbriqués au sein des insertions, garantissant que les structures d'interface complexes sont préservées et rendues correctement.

**Exemple :**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // nombre
          // ou
          name: "John", // chaîne
          // ou
          name: <span>John</span>, // élément React
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // nombre
          // ou
          name: "John", // chaîne de caractères
          // ou
          name: <span>John</span>, // élément React
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // ou
            name: 'John',
            // ou
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // nombre
          // ou
          name: "John", // chaîne
          // ou
          name: <span>John</span>, // élément Preact
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // nombre
          // ou
          name: "John", // chaîne
          // ou
          name: <span>John</span>, // élément Solid
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // nombre
        // ou
        name: "John", // chaîne
      })}
    </div>
    ```

  </Tab>
</Tabs>

## Localisation : nouveau hook `useIntl`

Un nouveau hook `useIntl()` est désormais disponible dans React, Next.js et Vue. Il fournit un objet `Intl` lié à la locale qui utilise automatiquement la langue courante pour formater les nombres, les dates et bien d'autres éléments, sans qu'il soit nécessaire de passer manuellement la locale.

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## Validation du schéma de contenu

Intlayer v8 introduit la validation de schéma pour les dictionnaires. Vous pouvez désormais définir des schémas de validation réutilisables dans votre configuration en utilisant Zod et les appliquer à vos fichiers de contenu. Cela garantit que votre contenu respecte toujours la structure attendue, en détectant les erreurs lors de la compilation.

### 1. Définir les schémas

Définissez vos schémas dans `intlayer.config.ts` :

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. Appliquer les schémas aux dictionnaires

Référencez la clé du schéma dans la définition de votre dictionnaire :

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- clé du schéma
  content: {
    title: "À propos de notre entreprise - En savoir plus sur nous",
    description:
      "Découvrez la mission, les valeurs et l'équipe de notre entreprise.",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

Si le contenu ne correspond pas au schéma (par ex., si le titre est trop court), le processus de build renverra une erreur.

---

### Détection automatique du contenu améliorée

Dans la v8, Intlayer détecte de manière intelligente la syntaxe Markdown, les balises HTML et les insertions de variables dans vos chaînes de contenu. Cela signifie que vous pouvez souvent omettre les fonctions d'aide comme `md()`, `html()` ou `insert()`.

Ce comportement est activé par défaut. Vous pouvez désormais affiner cette détection soit globalement dans votre `intlayer.config.ts`, soit par dictionnaire.

#### Contrôle granulaire

Vous pouvez activer ou désactiver des types spécifiques de transformations :

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (par défaut)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // Désactiver la détection automatique des insertions
    },
  },
};
```

**Comportement v7 (enveloppement manuel) :**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**Comportement v8 (détection automatique) :**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // Peut aussi être défini par la définition du dictionnaire ou globalement dans intlayer.config.ts
  content: {
    myMarkdown: "## Hello World", // Détecté automatiquement comme Markdown
    myHTML: "<p>Hello World</p>", // Détecté automatiquement comme HTML
    myInsertion: "Hi {{name}}", // Détecté automatiquement comme Insertion
  },
};
```

Le résultat JSON sous-jacent reste le même, préservant les informations de type riches nécessaires au rendu :

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## Hello World"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>Hello World</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Salut {{name}}"
    }
  }
}
```

---

## Outils : Améliorations de l'extension VSCode

L'extension Intlayer pour VSCode reçoit d'importantes mises à jour en v8 pour rationaliser votre flux de travail d'internationalisation :

- **Temps de démarrage** : Amélioration des performances à l'ouverture d'un projet.
- **Mise en cache** : Couche de cache améliorée pour une validation et une autocomplétion quasi instantanées.
- **Détection des clés inutilisées & des clés dupliquées** : Nouvelles fonctionnalités pour détecter automatiquement les **clés inutilisées** et les **clés dupliquées** dans vos dictionnaires, vous aidant à garder votre contenu propre et efficace.

---

## Optimisations du compilateur

Intlayer v8 inclut une nouvelle couche de mise en cache pour le compilateur Markdown et HTML. Cela garantit que les chaînes de contenu identiques avec la même configuration ne sont analysées qu'une seule fois, réduisant ainsi considérablement la surcharge lors des re-renders ou lorsque le même contenu est utilisé à plusieurs endroits.

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // Extraire le contenu des composants dans des dictionnaires
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // Optimise les imports en remplaçant useIntlayer par des imports directs de dictionnaires
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Pour Vue / Svelte, vous devrez installer le package de compilateur approprié :
>
> ```bash
> # Pour Vue
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Pour Svelte
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## Flexibilité : mode d'import unifié

La propriété booléenne `live` a été dépréciée au profit d'une propriété `importMode` plus complète. Cela permet de définir explicitement comment les dictionnaires doivent être chargés : statiquement, dynamiquement ou via une synchronisation en direct.

### Modes

- **`static`** (par défaut) : Le dictionnaire est bundlé au moment du build. Idéal pour les performances.
- **`dynamic`** : Le dictionnaire est chargé à l'exécution (par ex., via une requête JSON ou suspense).
- **`fetch`** : Le dictionnaire est récupéré depuis le CMS/serveur à l'exécution et synchronisé.

**Migration :**

| v7 Config     | v8 Config                             |
| :------------ | :------------------------------------ |
| `live: true`  | `importMode: 'fetch'`                 |
| `live: false` | `importMode: 'static'` (ou 'dynamic') |

Remarque : Dans Intlayer v8, la propriété `importMode` a été déplacée de la configuration `build` vers la configuration `dictionary` dans `intlayer.config.ts`. Cela vous permet de définir un mode d'importation par défaut pour tous vos dictionnaires tout en pouvant le remplacer pour chaque dictionnaire individuellement.

**Exemple de configuration globale :**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // Valeur globale par défaut
  },
  // ...
};
```

**Exemple de dictionnaire :**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // Remplace la config globale
    content: { ... }
}
```

---

## Contrôle de l'emplacement des dictionnaires

v8 introduit la propriété `location` pour gérer explicitement où se trouvent les dictionnaires et comment ils se synchronisent. Cela est particulièrement utile pour les workflows hybrides impliquant à la fois des fichiers locaux et du contenu CMS distant.

### Options

- **`local`** : Le dictionnaire existe uniquement localement. Il ne sera pas poussé vers le CMS distant.
- **`remote`** : Le dictionnaire est géré à distance. Une fois poussé sur le CMS, il sera détaché de la version locale. Le dictionnaire distant sera récupéré depuis le CMS.
- **`local_and_remote`** : Le dictionnaire existe dans les deux emplacements. Les modifications locales sont poussées, et les modifications distantes sont récupérées (synchronisées).

**Example:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // Conserver ce dictionnaire uniquement en local
    content: { ... }
}
```

---

## Séparation de la configuration du système

Intlayer v8 sépare la configuration des sources de contenu des chemins système internes et de sortie. Cela allège la propriété `content` et clarifie quelles options sont destinées à la gestion par l'utilisateur par rapport à celles gérées par le système Intlayer.

Les propriétés suivantes ont été déplacées de `content` vers une nouvelle propriété `system` dans `intlayer.config.ts` :

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**Comportement v7 :**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // Mélangé avec la configuration source
  },
};
```

**Comportement v8 :**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // Séparé clairement
  },
};
```

---

## Séparation des répertoires de contenu et de code

Intlayer v8 sépare la configuration des fichiers de définition de contenu de la configuration pour la transformation du code. Cela permet une surveillance et une analyse plus précises, améliorant les performances du build.

Auparavant, `contentDir` était utilisé à la fois pour surveiller les fichiers `.content.*` et pour analyser le code à la recherche des appels à `useIntlayer`. Désormais :

- **`contentDir`** : Spécifiquement pour vos fichiers de déclaration de contenu.
- **`codeDir`** : Spécifiquement pour le code de votre application nécessitant une transformation (par ex. élagage, optimisation).

Migration :

Si vous aviez précédemment défini `contentDir`, Intlayer v8 l'utilisera également par défaut pour `codeDir`, mais affichera un avertissement. Vous devriez définir explicitement `codeDir` dans votre configuration.

**Comportement en v7 :**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // Utilisé à la fois pour le contenu et le code
  },
};
```

**Comportement en v8 :**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // Ne surveille ici que les fichiers src/content/*.content.* et @packages/design-system/dist/*.content.*
    codeDir: ["src", "@packages/design-system"], // Ne scanne ici que le code pour transformation et les fichiers @packages/design-system/src/*.content.*
  },
};
```

---

## Framework : Améliorations pour Svelte

Le contenu Markdown et HTML dans Svelte est désormais automatiquement converti en HTML lorsqu'il est stringifié. Cela facilite grandement l'utilisation de la syntaxe Svelte `{@html}`, car vous pouvez maintenant simplement passer le nœud de contenu directement.

---

## Notes de migration depuis la v7

### Modifications de configuration

- **Propriété `live`** : La propriété `live` dans les dictionnaires est obsolète. Utilisez `importMode: 'fetch'` à la place.
- **`.set()` vers `.use()`** : La méthode `.set()` pour les overrides Markdown et HTML a été renommée en `.use()` pour une meilleure cohérence avec les autres API du framework.
- **`contentDir` et `codeDir`** : `contentDir` est désormais spécifiquement destiné aux fichiers de contenu. Une nouvelle propriété `codeDir` a été ajoutée pour la transformation du code. Si `codeDir` n'est pas défini, Intlayer utilisera `contentDir` par défaut et affichera un avertissement dans les logs.
- **Validation du schéma** : Pour utiliser la nouvelle fonctionnalité `schema`, assurez-vous d'avoir `zod` installé dans votre projet.

---

## Liens utiles

- [Référence de configuration](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/configuration.md)
- [Documentation des fichiers de contenu](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/dictionary/content_file.md)
- [Documentation du contenu HTML](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/dictionary/html.md)
- [Documentation du contenu Markdown](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/dictionary/markdown.md)
- [Documentation des réécritures d'URL personnalisées](https://github.com/aymericzip/intlayer/blob/main/docs/docs/fr/custom_url_rewrites.md)
