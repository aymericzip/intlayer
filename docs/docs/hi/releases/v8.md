---
createdAt: 2025-09-22
updatedAt: 2026-01-26
title: "नया Intlayer v8 - क्या नया है?"
description: "जानें Intlayer v8 में क्या नया है। डेवलपर अनुभव, सामग्री सत्यापन, और शब्दकोश प्रबंधन में प्रमुख सुधार।"
keywords:
  - Intlayer
  - CMS
  - Developer Experience
  - Features
  - React
  - Next.js
  - JavaScript
  - TypeScript
slugs:
  - doc
  - releases
  - v8
---

# नया Intlayer v8 - क्या नया है?

Intlayer v8 में आपका स्वागत है! यह रिलीज़ डेवलपर अनुभव को बेहतर बनाने (स्वचालित कंटेंट डिटेक्शन के साथ), डेटा की अखंडता सुनिश्चित करने के लिए स्कीमा सत्यापन (schema validation), और डिक्शनरी प्रबंधन पर अधिक नियंत्रण प्रदान करने पर केंद्रित है।

## सामग्री तालिका

<TOC levels={[2]} maxDepth={1} />

---

## HTML कंटेंट सपोर्ट

Intlayer v8 `html()` फ़ंक्शन पेश करता है, जो आपको अपनी डिक्शनरीज़ में HTML-जैसी सामग्री एम्बेड करने और रनटाइम पर टैग्स को कस्टम कॉम्पोनेंट्स से मैप करने की अनुमति देता है। यह उन रिच टेक्स्ट के लिए आदर्श है जिन्हें सिर्फ Markdown से अधिक आवश्यकता होती है, या जब आपको अपने कंटेंट में इंटरएक्टिव कॉम्पोनेंट्स इंजेक्ट करने की ज़रूरत हो।

**उदाहरण:**

```typescript fileName="src/example.content.ts"
import { html } from "intlayer";

export default {
  key: "my-key",
  content: {
    myRichText: html("Click <CustomLink>here</CustomLink> for more info"),
  },
};
```

**उपयोग:**

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer, HTMLProvider } from "next-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* प्रत्यक्ष रेंडरिंग (मानक टैग स्वचालित रूप से काम करते हैं) */}
        {myRichText}

        {/* .use() के साथ कस्टमाइज़ करना */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* ग्लोबल कस्टमाइज़ेशन के लिए provider का उपयोग */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer, HTMLProvider } from "react-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* प्रत्यक्ष रेंडरिंग (मानक टैग स्वचालित रूप से काम करते हैं) */}
        {myRichText}

        {/* .use() के साथ कस्टमाइज़ करना */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}

        {/* वैश्विक कस्टमाइज़ेशन के लिए Provider का उपयोग */}
        <HTMLProvider
          components={{
            CustomLink: ({ children }) => <a href="/details">{children}</a>,
          }}
        >
          {myRichText}
        </HTMLProvider>
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myRichText } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <!-- प्रत्यक्ष रेंडरिंग -->
        <component :is="myRichText" />

        <!-- .use() के साथ अनुकूलन -->
        <component
          :is="myRichText.use({
            CustomLink: (props) => h('a', { href: '/details' }, props.children),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer, HTMLProvider } from "preact-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* प्रत्यक्ष रेंडरिंग */}
        {myRichText}

        {/* .use() के साथ अनुकूलन */}
        {myRichText.use({
          CustomLink: ({ children }) => <a href="/details">{children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myRichText } = useIntlayer("my-key");

    return (
      <div>
        {/* प्रत्यक्ष रेंडरिंग */}
        {myRichText}

        {/* .use() के साथ कस्टमाइज़ करना */}
        {myRichText.use({
          CustomLink: (props) => <a href="/details">{props.children}</a>,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";
      const { myRichText } = useIntlayer("my-key");
    </script>

    <div>
      <!-- प्रत्यक्ष रेंडरिंग -->
      {@html myRichText}

      <!-- .use() के साथ कस्टमाइज़ करना -->
      {@html myRichText.use({
        CustomLink: ({ children }) => `<a href="/details">${children}</a>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

अधिक जानकारी के लिए, देखें [HTML सामग्री प्रलेखन](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/dictionary/html.md).

---

## कस्टम URL पुनर्लेखन

Intlayer v8 ने **Custom URL Rewrites** के लिए समर्थन पेश किया है, जिससे आप ऐसे locale-विशिष्ट पथ परिभाषित कर सकते हैं जो मानक `/locale/path` संरचना से भिन्न होते हैं। यह लोकल SEO बेहतर बनाने और गैर-अंग्रेजी बोलने वाले उपयोगकर्ताओं के लिए अधिक प्राकृतिक उपयोगकर्ता अनुभव प्रदान करने के लिए एक शक्तिशाली फ़ीचर है।

**v8 में मुख्य सुधार:**

- **Framework Formatters**: नए `nextjsRewrite`, `svelteKitRewrite`, `reactRouterRewrite`, `vueRouterRewrite`, `solidRouterRewrite`, `tanstackRouterRewrite`, `nuxtRewrite`, और `viteRewrite` ताकि प्रत्येक राउटर के लिए idiomatic pattern syntax प्रदान किया जा सके।
- **`useRewriteURL` Hook**: एक नया क्लाइंट-साइड हूक जो एड्रैस बार को बिना राउटर नेविगेशन ट्रिगर किए "सुघड़" लोकलाइज़्ड URL के लिए चुपचाप सही करता है।
- **स्वचालित SEO रीडायरेक्ट्स**: बिल्ट-इन प्रॉक्सी अब मैन्युअली टाइप किए गए कैनॉनिकल पाथ (उदा., `/fr/about`) से उपयोगकर्ताओं को उनके अधिक सुंदर लोकलाइज़्ड वर्शन (उदा., `/fr/a-propos`) पर स्वचालित रूप से रीडायरेक्ट कर देते हैं।

**उदाहरण कॉन्फ़िगरेशन:**

<Tabs group='routers'>
  <Tab label="Next.js" value="nextjs">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nextjsRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-no-default",
        rewrite: nextjsRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
    <Tab label="React Router" value="reactrouter">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { reactRouterRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: reactRouterRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Vite (Vue, Solid, Svelte)" value="vite">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { viteRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: viteRewrite({
          "/:locale/about": {
            fr: "/:locale/a-propos",
            es: "/:locale/acerca-de",
          },
          "/:locale/products/:id": {
            fr: "/:locale/produits/:id",
            es: "/:locale/productos/:id",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="Nuxt" value="nuxt">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { nuxtRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: nuxtRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
  <Tab label="SvelteKit" value="sveltekit">

    ```typescript fileName="intlayer.config.ts"
    import { Locales, type IntlayerConfig } from "intlayer";
    import { svelteKitRewrite } from "intlayer/routing";

    const config: IntlayerConfig = {
      internationalization: {
        locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],
        defaultLocale: Locales.ENGLISH,
      },
      routing: {
        mode: "prefix-all",
        rewrite: svelteKitRewrite({
          "/[locale]/about": {
            fr: "/[locale]/a-propos",
            es: "/[locale]/acerca-de",
          },
          "/[locale]/products/[id]": {
            fr: "/[locale]/produits/[id]",
            es: "/[locale]/productos/[id]",
          },
        }),
      },
    };

    export default config;
    ```

  </Tab>
</Tabs>

यह फ़ीचर Intlayer प्रॉक्सी के माध्यम से **Next.js** और **Vite** में डिफ़ॉल्ट रूप से समर्थित है, और इसे अन्य राउटर्स जैसे **TanStack Router**, **React Router**, **Vue Router**, **SvelteKit**, और **Solid Router** में आसानी से एकीकृत किया जा सकता है।

अधिक जानकारी और एकीकरण मार्गदर्शिकाओं के लिए, देखें [कस्टम URL पुनर्लेखन दस्तावेज़](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/custom_url_rewrites.md).

---

## Markdown MDX और HTML: `.use()`

Intlayer v8 समृद्ध सामग्री के लिए API को एकीकृत करता है। `.set()` मेथड (जो v7 में Markdown के लिए उपयोग होता था) का नाम बदलकर [`.use()`](https://github.com/aymericzip/intlayer/blob/main/packages/react-intlayer/src/useIntlayer.tsx) कर दिया गया है ताकि Markdown और HTML दोनों में एक समान अनुभव मिल सके।

### क्रॉस-फ़्रेमवर्क Markdown पार्सर

Intlayer अब एक शक्तिशाली, क्रॉस-फ्रेमवर्क Markdown पार्सर को एकीकृत करता है जो **MDX** का समर्थन करता है। इसका मतलब है कि आप अपने Markdown कंटेंट के भीतर सीधे कंपोनेंट्स का उपयोग कर सकते हैं, बिलकुल HTML की तरह।

- **MDX समर्थन**: अपने Markdown के अंदर React/Vue/Svelte कंपोनेंट्स का उपयोग करें।
- **SSR तैयार**: पार्सर Server-Side Rendering (SSR) के लिए अनुकूलित है, जिससे तेज़ शुरुआती लोड और SEO-अनुकूल समृद्ध कंटेंट सुनिश्चित होता है।
- **सुसंगत API**: अपने एप्लिकेशन के कंपोनेंट्स को Markdown/MDX टैग्स से मैप करने के लिए `.use()` का उपयोग करें।

**Markdown/MDX का उदाहरण:**

```typescript fileName="src/example.content.ts"
import { md } from "intlayer";

export default {
  key: "my-key",
  content: {
    // MDX-like syntax in Markdown
    myMarkdown: md("## Check this out \n\n <InteractiveChart />"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```html
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myMarkdown } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myMarkdown.use({
            InteractiveChart: (props) => h(Chart, props),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: () => <Chart />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myMarkdown } = useIntlayer("my-key");

    return (
      <div>
        {myMarkdown.use({
          InteractiveChart: (props) => <Chart {...props} />,
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```html
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myMarkdown } = useIntlayer("my-key");
    </script>

    <div>
      {@html myMarkdown.use({
        InteractiveChart: (props) => `<div class="chart"></div>`,
      })}
    </div>
    ```

  </Tab>
</Tabs>

अधिक जानकारी के लिए [Markdown प्रलेखन](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/dictionary/markdown.md) देखें।

---

### उन्नत इनसर्शन मान

v8 में, इनसर्शन मान अब स्ट्रिंग और नंबर के अलावा **React elements (या Vue nodes)** भी स्वीकार कर सकते हैं। इससे आप अपने इनसर्शन टेम्पलेट्स में समृद्ध, इंटरैक्टिव कंपोनेंट्स सीधे इंजेक्ट कर सकते हैं।

Intlayer अब insertions के भीतर nested React और Preact nodes को मजबूती से संभालता है, जिससे जटिल UI संरचनाएँ संरक्षित रहें और सही ढंग से रेंडर हों।

**उदाहरण:**

```typescript fileName="src/example.content.ts"
import { insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myInsertion: insert("Hi {{name}}"),
  },
};
```

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntlayer } from "next-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // संख्या
          // या
          name: "John", // स्ट्रिंग
          // या
          name: <span>John</span>, // React तत्व
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntlayer } from "react-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // संख्या
          // या
          name: "John", // स्ट्रिंग
          // या
          name: <span>John</span>, // React तत्व
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { h } from "vue";
    import { useIntlayer } from "vue-intlayer";

    const { myInsertion } = useIntlayer("my-key");
    </script>

    <template>
      <div>
        <component
          :is="myInsertion({
            name: 2,
            // या
            name: 'John',
            // या
            name: h('span', 'John'),
          })"
        />
      </div>
    </template>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntlayer } from "preact-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // संख्या
          // या
          name: "John", // स्ट्रिंग
          // या
          name: <span>John</span>, // Preact तत्व
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntlayer } from "solid-intlayer";

    const { myInsertion } = useIntlayer("my-key");

    return (
      <div>
        {myInsertion({
          name: 2, // संख्या
          // या
          name: "John", // स्ट्रिंग
          // या
          name: <span>John</span>, // Solid तत्व
        })}
      </div>
    );
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntlayer } from "svelte-intlayer";

      const { myInsertion } = useIntlayer("my-key");
    </script>

    <div>
      {myInsertion({
        name: 2, // संख्या
        // या
        name: "John", // स्ट्रिंग
      })}
    </div>
    ```

  </Tab>
</Tabs>

## स्थानीयकरण: नया `useIntl` हुक

React, Next.js और Vue में अब एक नया `useIntl()` हुक उपलब्ध है। यह एक locale-bound `Intl` ऑब्जेक्ट प्रदान करता है जो स्वतः ही वर्तमान भाषा का उपयोग करके संख्याओं, तिथियों और अन्य को फॉर्मेट करता है, और आपको मैन्युअली locale पास करने की आवश्यकता नहीं रहती।

<Tabs group='framework'>
  <Tab label="Next.js" value="nextjs">

    ```tsx
    import { useIntl } from "next-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="React" value="react">

    ```tsx
    import { useIntl } from "react-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Vue" value="vue">

    ```vue
    <script setup>
    import { useIntl } from "vue-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    </script>
    ```

  </Tab>
  <Tab label="Preact" value="preact">

    ```tsx
    import { useIntl } from "preact-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Solid" value="solid">

    ```tsx
    import { useIntl } from "solid-intlayer";

    const intl = useIntl();

    const formattedPrice = new intl.NumberFormat({
      style: "currency",
      currency: "USD",
    }).format(123.45);
    ```

  </Tab>
  <Tab label="Svelte" value="svelte">

    ```svelte
    <script>
      import { useIntl } from "svelte-intlayer";

      const intl = useIntl();

      const formattedPrice = new intl.NumberFormat({
        style: "currency",
        currency: "USD",
      }).format(123.45);
    </script>
    ```

  </Tab>
</Tabs>

---

## सामग्री स्कीमा सत्यापन

Intlayer v8 डिक्शनरीज़ के लिए स्कीमा सत्यापन पेश करता है। अब आप Zod का उपयोग करके अपनी कॉन्फ़िगरेशन में पुन: प्रयोज्य सत्यापन स्कीमा परिभाषित कर सकते हैं और उन्हें अपनी कंटेंट फ़ाइलों पर लागू कर सकते हैं। यह सुनिश्चित करता है कि आपकी सामग्री हमेशा अपेक्षित संरचना का पालन करे, और बिल्ड समय पर त्रुटियों को पकड़ ले।

### 1. स्कीमा परिभाषित करें

अपने स्कीमा `intlayer.config.ts` में परिभाषित करें:

```typescript fileName="intlayer.config.ts"
import { z } from "zod";

export default {
  schemas: {
    "seo-metadata": z.object({
      title: z.string().min(50).max(60),
      description: z.string().min(150).max(160),
    }),
  },
};
```

### 2. स्कीमाओं को डिक्शनरीज़ पर लागू करें

अपनी डिक्शनरी परिभाषा में स्कीमा की कुंजी का संदर्भ दें:

```typescript fileName="src/example.content.ts"
import { type Dictionary } from "intlayer";

const aboutPageMetaContent = {
  key: "about-page-meta",
  schema: "seo-metadata", // <-- स्कीमा कुंजी निर्दिष्ट करता है
  content: {
    title: "हमारी कंपनी के बारे में - हमारे बारे में और जानें",
    description: "हमारी कंपनी के मिशन, मूल्यों और टीम को जानें।",
  },
} satisfies Dictionary<"seo-metadata">;

export default aboutPageMetaContent;
```

यदि कंटेंट स्कीमा से मेल नहीं खाता (उदा., शीर्षक बहुत छोटा है), तो बिल्ड प्रक्रिया त्रुटि देगी।

---

### उन्नत स्वचालित कंटेंट पहचान

v8 में, Intlayer आपके कंटेंट स्ट्रिंग्स में Markdown सिंटैक्स, HTML टैग्स, और वेरिएबल इन्सर्शन को बुद्धिमानी से पहचानता है। इसका मतलब है कि आप अक्सर `md()`, `html()`, या `insert()` जैसे हेल्पर फंक्शन्स को छोड़ सकते हैं।

यह व्यवहार डिफ़ॉल्ट रूप से सक्षम है। आप अब इस पहचान को या तो ग्लोबली अपनी `intlayer.config.ts` में या प्रति डिक्शनरी के आधार पर सूक्ष्म रूप से अनुकूलित कर सकते हैं।

#### सूक्ष्म नियंत्रण

आप विशेष प्रकार के रूपांतरण को सक्षम या अक्षम कर सकते हैं:

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    // contentAutoTransformation: false (डिफ़ॉल्ट)
    contentAutoTransformation: {
      markdown: true,
      html: true,
      insertion: false, // स्वचालित insertion का पता लगाने को अक्षम करें
    },
  },
};
```

**v7 व्यवहार (मैनुअल रैपिंग):**

```typescript fileName="src/example.content.ts"
import { md, insert } from "intlayer";

export default {
  key: "my-key",
  content: {
    myMarkdown: md("## Hello World"),
    myInsertion: insert("Hi {{name}}"),
  },
};
```

**v8 व्यवहार (स्वचालित पहचान):**

```typescript fileName="src/example.content.ts"
export default {
  key: "my-key",
  contentAutoTransformation: true, // इसे dictionary परिभाषा में या intlayer.config.ts में वैश्विक रूप से भी सेट किया जा सकता है
  content: {
    myMarkdown: "## नमस्ते दुनिया", // स्वचालित रूप से Markdown के रूप में पहचाना गया
    myHTML: "<p>नमस्ते दुनिया</p>", // स्वचालित रूप से HTML के रूप में पहचाना गया
    myInsertion: "नमस्ते {{name}}", // स्वचालित रूप से Insertion के रूप में पहचाना गया
  },
};
```

अंतर्निहित JSON परिणाम समान रहता है, रेंडरिंग के लिए आवश्यक समृद्ध प्रकार की जानकारी को संरक्षित करते हुए:

```json
{
  "key": "my-key",
  "content": {
    "myMarkdown": {
      "nodeType": "markdown",
      "markdown": "## नमस्ते दुनिया"
    },
    "myHTML": {
      "nodeType": "html",
      "html": "<p>नमस्ते दुनिया</p>"
    },
    "myInsertion": {
      "nodeType": "insertion",
      "insertion": "Hi {{name}}"
    }
  }
}
```

---

## टूलिंग: VSCode एक्सटेंशन सुधार

Intlayer VSCode एक्सटेंशन को v8 में बड़े अपडेट मिले हैं ताकि आपका internationalization वर्कफ़्लो और अधिक सुगम हो सके:

- **स्टार्टअप समय**: किसी प्रोजेक्ट को खोलते समय प्रदर्शन में सुधार।
- **कैशिंग**: लगभग तात्कालिक मान्यता और ऑटोकम्प्लीशन के लिए बेहतर कैशिंग लेयर।
- **अनुपयोगी कुंजियाँ और डुप्लिकेट कुंजियाँ पहचान**: आपकी डिक्शनरीज़ में **अनुपयोगी कुंजियाँ** और **डुप्लिकेट कुंजियाँ** को स्वचालित रूप से पहचानने की नई सुविधाएँ, जो आपके कंटेंट को साफ़ और प्रभावी बनाए रखने में मदद करती हैं।

---

## कम्पाइलर अनुकूलन

Intlayer v8 में Markdown और HTML compiler के लिए एक नया कैशिंग लेयर शामिल है। यह सुनिश्चित करता है कि एक ही कॉन्फ़िगरेशन के साथ समान कंटेंट स्ट्रिंग्स केवल एक बार पार्स की जाएँ, जिससे री-रेंडर के दौरान या जब एक ही कंटेंट को कई स्थानों पर उपयोग किया जाता है तो ओवरहेड काफी कम हो जाता है।

<Tabs group='bundler'>
  <Tab label="Next.js" value="nextjs">
  
    ```typescript fileName="babel.config.js"
      const {
      intlayerExtractBabelPlugin,
      intlayerOptimizeBabelPlugin,
      getExtractPluginOptions,
      getOptimizePluginOptions,
    } = require('@intlayer/babel');

    module.exports = {
      presets: ['next/babel'],
      plugins: [
        // घटकों से सामग्री को डिक्शनरी में निकालें
        [intlayerExtractBabelPlugin, getExtractPluginOptions()],
        // useIntlayer को सीधे dictionary imports से बदलकर imports का अनुकूलन करें
        [intlayerOptimizeBabelPlugin, getOptimizePluginOptions()],
      ],
    };
    ```

  </Tab>
  <Tab label="Vite" value="vite">
   
    ```typescript fileName="vite.config.js"
    import { defineConfig } from 'vite';
    import {intlayer, intlayerCompiler} from 'vite-intlayer';

    export default defineConfig({
      plugins: [intlayer(), intlayerCompiler()],
    });
    ```

> Vue / Svelte के लिए आपको उपयुक्त compiler पैकेज इंस्टॉल करना होगा:
>
> ```bash
> # Vue के लिए
> npm install @intlayer/vue-compiler
> ```
>
> ```bash
> # Svelte के लिए
> npm install @intlayer/svelte-compiler
> ```

  </Tab>
</Tabs>

---

## लचीलापन: एकीकृत आयात मोड

`live` boolean प्रॉपर्टी को अब अधिक समग्र `importMode` प्रॉपर्टी के पक्ष में deprecated कर दिया गया है। इससे यह स्पष्ट रूप से परिभाषित करना संभव होता है कि डिक्शनरी कैसे लोड की जानी चाहिए: statically, dynamically, या live sync के माध्यम से।

### मोड

- **`static`** (डिफ़ॉल्ट): डिक्शनरी को बिल्ड समय पर बंडल किया जाता है। प्रदर्शन के लिए सबसे अच्छा।
- **`dynamic`**: डिक्शनरी रनटाइम पर लोड की जाती है (उदा., JSON fetch या suspense के माध्यम से)।
- **`fetch`**: डिक्शनरी को रनटाइम पर CMS/Server से फेच किया जाता है और सिंक्रनाइज़ किया जाता है।

**माइग्रेशन:**

| v7 कॉन्फ़िग   | v8 कॉन्फ़िग                           |
| :------------ | :------------------------------------ |
| `live: true`  | `importMode: 'fetch'`                 |
| `live: false` | `importMode: 'static'` (or 'dynamic') |

Note: Intlayer v8 में, `importMode` प्रॉपर्टी को `build` कॉन्फ़िगरेशन से हटा कर `intlayer.config.ts` में `dictionary` कॉन्फ़िगरेशन में ले जाया गया है। यह आपको सभी डिक्शनरीज़ के लिए एक डिफ़ॉल्ट import mode परिभाषित करने की अनुमति देता है, जबकि आप इसे प्रति-डिक्शनरी आधार पर ओवरराइड भी कर सकते हैं।

**वैश्विक कॉन्फ़िगरेशन उदाहरण:**

```typescript fileName="intlayer.config.ts"
export default {
  dictionary: {
    importMode: "dynamic", // वैश्विक डिफ़ॉल्ट
  },
  // ...
};
```

**डिक्शनरी उदाहरण:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    importMode: "fetch", // वैश्विक कॉन्फ़िगरेशन को ओवरराइड करता है
    content: { ... }
}
```

---

## डिक्शनरी स्थान नियंत्रण

v8 ने `location` प्रॉपर्टी जोड़ी है जो स्पष्ट रूप से नियंत्रित करती है कि शब्दकोश कहाँ रहते हैं और वे कैसे सिंक्रोनाइज़ होते हैं। यह विशेष रूप से उन हाइब्रिड वर्कफ़्लो के लिए उपयोगी है जिनमें स्थानीय फ़ाइलें और रिमोट CMS दोनों शामिल हों।

### विकल्प

- **`local`**: शब्दकोश केवल स्थानीय रूप से मौजूद है। इसे रिमोट CMS पर पुश नहीं किया जाएगा।
- **`remote`**: शब्दकोश रिमोट रूप से प्रबंधित होता है। एक बार CMS पर पुश करने के बाद यह स्थानीय वाले से अलग कर दिया जाएगा। रिमोट शब्दकोश CMS से पुल किया जाएगा।
- **`local_and_remote`**: शब्दकोश दोनों स्थानों पर मौजूद रहता है। स्थानीय परिवर्तन पुश किए जाते हैं, और रिमोट परिवर्तन पुल किए जाते हैं (सिंक्रोनाइज़ किए जाते हैं)।

**उदाहरण:**

```typescript fileName="src/example.content.ts"
export default {
    key: 'my-key',
    location: "local", // इस शब्दकोश को केवल स्थानीय रखें
    content: { ... }
}
```

---

## सिस्टम कॉन्फ़िगरेशन पृथक्करण

Intlayer v8 सामग्री स्रोतों की कॉन्फ़िगरेशन को आंतरिक सिस्टम और आउटपुट पाथ्स से अलग करता है। इससे `content` प्रॉपर्टी साफ-सुथरी रहती है और यह स्पष्ट होता है कि कौन-सी सेटिंग्स उपयोगकर्ता द्वारा प्रबंधित करने के लिए हैं और कौन-सी Intlayer सिस्टम द्वारा प्रबंधित की जाती हैं।

निम्नलिखित प्रॉपर्टीज़ को `content` से हटाकर `intlayer.config.ts` में एक नए `system` प्रॉपर्टी में स्थानांतरित किया गया है:

- `dictionariesDir`
- `moduleAugmentationDir`
- `unmergedDictionariesDir`
- `typesDir`
- `mainDir`
- `configDir`
- `cacheDir`
- `outputFilesPatternWithPath`

**v7 व्यवहार:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
    dictionariesDir: ".intlayer/dictionary", // स्रोत कॉन्फ़िग के साथ मिश्रित
  },
};
```

**v8 व्यवहार:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src"],
  },
  system: {
    dictionariesDir: ".intlayer/dictionary", // स्पष्ट रूप से अलग किया गया
  },
};
```

---

## सामग्री और कोड डायरेक्टरी का विभाजन

Intlayer v8 सामग्री परिभाषा फ़ाइलों की कॉन्फ़िगरेशन को कोड ट्रांसफ़ॉर्मेशन की कॉन्फ़िगरेशन से अलग करता है। इससे वॉचिंग और स्कैनिंग अधिक सटीक हो जाती है, जिससे बिल्ड प्रदर्शन में सुधार होता है।

पूर्व में, `contentDir` का उपयोग दोनों के लिए किया जाता था: `.content.*` फ़ाइलों को वॉच करने और `useIntlayer` कॉल्स के लिए कोड स्कैन करने के लिए। अब:

- **`contentDir`**: विशेष रूप से आपकी सामग्री घोषणा फ़ाइलों के लिए।
- **`codeDir`**: विशेष रूप से आपके एप्लिकेशन कोड के लिए जिन्हें ट्रांसफ़ॉर्मेशन की आवश्यकता है (उदा., pruning, optimization)।

**माइग्रेशन:**

यदि आपने पहले `contentDir` सेट किया था, तो Intlayer v8 इसे `codeDir` के लिए भी डिफ़ॉल्ट के रूप में उपयोग करेगा, लेकिन एक चेतावनी लॉग करेगा। आपको अपनी कॉन्फ़िगरेशन में स्पष्ट रूप से `codeDir` को परिभाषित करना चाहिए।

**v7 व्यवहार:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src", "@packages/design-system"], // सामग्री और कोड दोनों के लिए उपयोग किया जाता है
  },
};
```

**v8 व्यवहार:**

```typescript fileName="intlayer.config.ts"
export default {
  content: {
    contentDir: ["src/content", "@packages/design-system"], // केवल यहाँ src/content/*.content.* और @packages/design-system/dist/*.content.* फ़ाइलों के लिए वॉच करें
    codeDir: ["src", "@packages/design-system"], // केवल यहाँ कोड ट्रांसफ़ॉर्मेशन के लिए स्कैन करें और @packages/design-system/src/*.content.* फ़ाइलों को स्कैन करें
  },
};
```

---

## Framework: Svelte में सुधार

Svelte में Markdown और HTML कंटेंट अब stringified होने पर स्वचालित रूप से HTML में पार्स होते हैं। इससे Svelte के `{@html}` सिंटैक्स के साथ उपयोग करना बहुत आसान हो जाता है, क्योंकि आप अब सीधे कंटेंट नोड पास कर सकते हैं।

---

## v7 से माइग्रेशन नोट्स

### कॉन्फ़िगरेशन में बदलाव

- **`live` property**: डिक्शनरीज़ में `live` प्रॉपर्टी अप्रचलित (deprecated) हो चुकी है। इसके बजाय `importMode: 'fetch'` का उपयोग करें।
- **`.set()` से `.use()`**: Markdown और HTML ओवरराइड्स के लिए `.set()` मेथड का नाम बदलकर `.use()` कर दिया गया है ताकि यह अन्य फ्रेमवर्क APIs के साथ बेहतर संगति दिखाए।
- **`contentDir` and `codeDir`**: `contentDir` अब विशेष रूप से content फ़ाइलों के लिए है। कोड ट्रांसफ़ॉर्मेशन के लिए एक नया `codeDir` प्रॉपर्टी जोड़ा गया है। यदि `codeDir` सेट नहीं है, तो Intlayer `contentDir` पर fallback करेगा और एक चेतावनी लॉग करेगा।
- **Schema Validation**: नए `schema` फीचर का उपयोग करने के लिए, सुनिश्चित करें कि आपके प्रोजेक्ट में `zod` इंस्टॉल है।

---

## उपयोगी लिंक

- [Configuration Reference](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/configuration.md)
- [Content File Documentation](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/dictionary/content_file.md)
- [HTML Content Documentation](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/dictionary/html.md)
- [मार्कडाउन सामग्री दस्तावेज़ीकरण](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/dictionary/markdown.md)
- [कस्टम URL री-राइट्स दस्तावेज़ीकरण](https://github.com/aymericzip/intlayer/blob/main/docs/docs/hi/custom_url_rewrites.md)
