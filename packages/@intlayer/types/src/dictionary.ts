import type {
  DeclaredLocales,
  LocalesValues,
  Schema,
  SchemaKeys,
} from './module_augmentation';
import type { NodeType } from './nodeType';

type BaseNode = number | string | boolean | null | undefined;

type TypedNodeBase = {
  nodeType: NodeType | `${NodeType}`;
};

export interface TypedNode<_NodeType = undefined> extends TypedNodeBase {}

type FetchableContentNode<NodeType> = (
  args?: any
) => ContentNode<NodeType> | Promise<ContentNode<NodeType>>;

export type ContentNode<
  T = undefined,
  FetchableNode = false,
  NodeType = T extends undefined ? BaseNode : T,
> =
  | NodeType
  | TypedNode<NodeType>
  | ((args?: any) => ContentNode<NodeType>)
  | (FetchableNode extends true ? FetchableContentNode<NodeType> : undefined);

// Utility types (unchanged)
type IsArray<T> = T extends any[] ? true : false;

type ReplaceContentValueArray<T, FetchableNode> = T extends (infer U)[]
  ? // Allow either a *single* typed node returning the entire array
    // or an array of typed nodes (or scalar nodes).
    ContentNode<T, FetchableNode> | ReplaceContentValue<U, FetchableNode>[]
  : never;

type ReplaceContentValueObject<T, FetchableNode> = {
  [K in keyof T]: ReplaceContentValue<T[K], FetchableNode>;
};

// Modified: allow a full ContentNode wrapper OR an object shape when T is an object
type ReplaceContentValue<
  NodeType,
  FetchableNode = true,
> = NodeType extends object
  ? IsArray<NodeType> extends true
    ? ReplaceContentValueArray<NodeType, FetchableNode>
    :
        | ContentNode<NodeType, FetchableNode>
        | ReplaceContentValueObject<NodeType, FetchableNode>
  : ContentNode<NodeType, FetchableNode>;

export type Fill =
  | boolean
  | string
  | Partial<Record<DeclaredLocales, boolean | string>>;

export type DictionaryId = string;
export type DictionaryKey = string;
export type DictionaryLocation = 'remote' | 'local' | 'local&remote' | 'plugin';

export type LocalDictionaryId =
  `${DictionaryKey}::${Dictionary['location']}::${Dictionary['filePath'] | DictionaryId}`;

export type DictionaryFormat = 'intlayer' | 'icu' | 'i18next' | 'vue-i18n';

/**
 * Common properties shared by all Dictionary variants.
 */
type DictionaryBase = {
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The schema of the dictionary, used for JSON validation
   */
  $schema?: 'https://intlayer.org/schema.json';

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For remote dictionaries, the id is the id of the dictionary in the remote server
   */
  id?: DictionaryId;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For remote dictionaries, the projectIds is the ids of the projects that can use this dictionary
   * A remote dictionary can be shared between multiple projects
   */
  projectIds?: string[];

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Unique Identifier for the dictionaries. Auto generated by the intlayer, it helps to identify the dictionary and know if it is a local or remote dictionary, and his location.
   */
  localId?: LocalDictionaryId;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For merged dictionaries, the localIds is the ids of the dictionaries that are merged
   */
  localIds?: LocalDictionaryId[];

  /**
   * The formatter to use for the dictionary.
   *
   * Default: 'intlayer'
   *
   * The formatter to use for the dictionary content.
   */
  format?: DictionaryFormat;

  /**
   * The key of the dictionary. If multiple dictionaries have the same key, intlayer will merge them.
   *
   * As convention, use '-' to separate the words in the key.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "content": { ... }
   * }
   * ```
   */
  key: DictionaryKey;

  /**
   * The title of the dictionary. Helps to identify the dictionary in the editor, and the CMS.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "title": "About Page",
   * "content": { ... }
   * }
   * ```
   */
  title?: string;

  /**
   * The description of the dictionary. Helps to understand the purpose of the dictionary in the editor, and the CMS.
   * The description is also used as context for translations generation.
   *
   * Example:
   * ```ts
   * {
   * "key": "about-page-meta",
   * "description":[
   * "This dictionary is manage the metadata of the About Page",
   * "Consider good practices for SEO:",
   * "- The title should be between 50 and 60 characters",
   * "- The description should be between 150 and 160 characters",
   * ].join('\n'),
   * "content": { ... }
   * }
   * ```
   */
  description?: string;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The available versions of the remote dictionary. Helps to know the versions of the dictionary that are available.
   */
  versions?: string[];

  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * The version of the remote dictionary. Helps to know the version of the dictionary that is currently used.
   */
  version?: string;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The file path of the local dictionary. Helps to know from what .content file the dictionary has been generated.
   */
  filePath?: string;

  /**
   * Helps to categorize the dictionaries. The tags can provide more context and instructions for the dictionary.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "tags": ["metadata","about-page"]
   * }
   * ```
   */
  tags?: string[];

  /**
   * Transform the dictionary in a per-locale dictionary.
   * Each field declared in a per-locale dictionary will be transformed in a translation node.
   * If missing, the dictionary will be treated as a multilingual dictionary.
   * If declared, do not use translation nodes in the content.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page",
   * "locale": "en",
   * "content": {
   * "multilingualContent": "English content"
   * }
   * }
   * ```
   */
  locale?: LocalesValues;

  /**
   * Instruction to fill the dictionary.
   * Can also be declared globally in the `intlayer.config.ts` file.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page",
   * "fill": true
   * }
   * ```
   */
  fill?: Fill;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Indicates if the dictionary has been auto filled.
   * In the case of conflicts, base dictionaryed will override auto filled dictionary.
   */
  filled?: true;

  /**
   * Indicates the priority of the dictionary.
   * In the case of conflicts, the dictionary with the highest priority will override the other dictionaries.
   */
  priority?: number;

  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * For remote dictionaries, indicates if the dictionary is live.
   */
  live?: boolean;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Indicates the location of the dictionary.
   */
  location?: DictionaryLocation;
};

/**
 * Strict Schema Branch:
 * If a schema is provided, it MUST be one of the SchemaKeys.
 */
type DictionaryWithSchema<
  ContentType,
  FetchableNode,
  K extends SchemaKeys = SchemaKeys,
> = K extends any
  ? {
      schema: K;
      content: ContentType extends undefined
        ? ReplaceContentValue<Schema<K>, FetchableNode> | Schema<K>
        :
            | ReplaceContentValue<ContentType & Schema<K>, FetchableNode>
            | (ContentType & Schema<K>);
    }
  : never;

/**
 * No Schema Branch
 */
type DictionaryWithoutSchema<ContentType, FetchableNode> = {
  schema?: undefined;
  content: ContentType extends undefined
    ? any
    : ReplaceContentValue<ContentType, FetchableNode> | ContentType;
};

/**
 * The Final Dictionary Type
 */
export type Dictionary<
  ContentType = undefined,
  SchemaKey extends SchemaKeys | undefined = undefined,
  FetchableNode = false,
> = DictionaryBase &
  (SchemaKey extends SchemaKeys
    ? DictionaryWithSchema<ContentType, FetchableNode, SchemaKey>
    : undefined extends SchemaKey // Check if SchemaKey is missing/undefined
      ?
          | DictionaryWithoutSchema<ContentType, FetchableNode>
          | DictionaryWithSchema<ContentType, FetchableNode>
      : never);

export type GetSubPath<T, P> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? GetSubPath<T[K], Rest>
    : never
  : P extends keyof T
    ? T[P]
    : T;
