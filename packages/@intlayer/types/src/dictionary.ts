import type {
  DeclaredLocales,
  LocalesValues,
  Schema,
  SchemaKeys,
} from './module_augmentation';
import type { NodeType } from './nodeType';

type BaseNode = number | string | boolean | null | undefined;

type TypedNodeBase = {
  nodeType: NodeType | `${NodeType}`;
};

export interface TypedNode<_NodeType = undefined> extends TypedNodeBase {}

type FetchableContentNode<NodeType> = (
  args?: any
) => ContentNode<NodeType> | Promise<ContentNode<NodeType>>;

export type ContentNode<
  T = undefined,
  FetchableNode = false,
  NodeType = T extends undefined ? BaseNode : T,
> =
  | NodeType
  | TypedNode<NodeType>
  | ((args?: any) => ContentNode<NodeType>)
  | (FetchableNode extends true ? FetchableContentNode<NodeType> : undefined);

// Utility types (unchanged)
type IsArray<T> = T extends any[] ? true : false;

type ReplaceContentValueArray<T, FetchableNode> = T extends (infer U)[]
  ? // Allow either a *single* typed node returning the entire array
    // or an array of typed nodes (or scalar nodes).
    ContentNode<T, FetchableNode> | ReplaceContentValue<U, FetchableNode>[]
  : never;

type ReplaceContentValueObject<T, FetchableNode> = {
  [K in keyof T]: ReplaceContentValue<T[K], FetchableNode>;
};

// Modified: allow a full ContentNode wrapper OR an object shape when T is an object
type ReplaceContentValue<
  NodeType,
  FetchableNode = true,
> = NodeType extends object
  ? IsArray<NodeType> extends true
    ? ReplaceContentValueArray<NodeType, FetchableNode>
    :
        | ContentNode<NodeType, FetchableNode>
        | ReplaceContentValueObject<NodeType, FetchableNode>
  : ContentNode<NodeType, FetchableNode>;

export type Fill =
  | boolean
  | string
  | Partial<Record<DeclaredLocales, boolean | string>>;

export type DictionaryId = string;
export type DictionaryKey = string;
export type DictionaryLocation =
  | 'remote'
  | 'local'
  | 'local&remote'
  | 'plugin'
  | (string & {});

export type LocalDictionaryId =
  `${DictionaryKey}::${Dictionary['location']}::${Dictionary['filePath'] | DictionaryId}`;

export type DictionaryFormat = 'intlayer' | 'icu' | 'i18next' | 'vue-i18n';

/**
 * Common properties shared by all Dictionary variants.
 */
type DictionaryBase = {
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The schema of the dictionary, used for JSON validation
   */
  $schema?: 'https://intlayer.org/schema.json';

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For remote dictionaries, the id is the id of the dictionary in the remote server
   */
  id?: DictionaryId;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For remote dictionaries, the projectIds is the ids of the projects that can use this dictionary
   * A remote dictionary can be shared between multiple projects
   */
  projectIds?: string[];

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Unique Identifier for the dictionaries. Auto generated by the intlayer, it helps to identify the dictionary and know if it is a local or remote dictionary, and his location.
   */
  localId?: LocalDictionaryId;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For merged dictionaries, the localIds is the ids of the dictionaries that are merged
   */
  localIds?: LocalDictionaryId[];

  /**
   * The formatter to use for the dictionary.
   *
   * Default: 'intlayer'
   *
   * The formatter to use for the dictionary content.
   */
  format?: DictionaryFormat;

  /**
   * The key of the dictionary. If multiple dictionaries have the same key, intlayer will merge them.
   *
   * As convention, use '-' to separate the words in the key.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "content": { ... }
   * }
   * ```
   */
  key: DictionaryKey;

  /**
   * The title of the dictionary. Helps to identify the dictionary in the editor, and the CMS.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "title": "About Page",
   * "content": { ... }
   * }
   * ```
   */
  title?: string;

  /**
   * The description of the dictionary. Helps to understand the purpose of the dictionary in the editor, and the CMS.
   * The description is also used as context for translations generation.
   *
   * Example:
   * ```ts
   * {
   * "key": "about-page-meta",
   * "description":[
   * "This dictionary is manage the metadata of the About Page",
   * "Consider good practices for SEO:",
   * "- The title should be between 50 and 60 characters",
   * "- The description should be between 150 and 160 characters",
   * ].join('\n'),
   * "content": { ... }
   * }
   * ```
   */
  description?: string;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The available versions of the remote dictionary. Helps to know the versions of the dictionary that are available.
   */
  versions?: string[];

  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * The version of the remote dictionary. Helps to know the version of the dictionary that is currently used.
   */
  version?: string;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The file path of the local dictionary. Helps to know from what .content file the dictionary has been generated.
   */
  filePath?: string;

  /**
   * Helps to categorize the dictionaries. The tags can provide more context and instructions for the dictionary.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page-meta",
   * "tags": ["metadata","about-page"]
   * }
   * ```
   */
  tags?: string[];

  /**
   * Transform the dictionary in a per-locale dictionary.
   * Each field declared in a per-locale dictionary will be transformed in a translation node.
   * If missing, the dictionary will be treated as a multilingual dictionary.
   * If declared, do not use translation nodes in the content.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page",
   * "locale": "en",
   * "content": {
   * "multilingualContent": "English content"
   * }
   * }
   * ```
   */
  locale?: LocalesValues;

  /**
   * Indicates if the content of the dictionary should be automatically transformed.
   * If true, the content will be transformed to the corresponding node type.
   * - Markdown: `### Title` -> `md('### Title')`
   * - HTML: `<div>Title</div>` -> `html('<div>Title</div>')`
   * - Insertion: `Hello {{name}}` -> `insert('Hello {{name}}')`
   *
   * Default: true
   */
  contentAutoTransformation?: boolean;

  /**
   * Instruction to fill the dictionary.
   * Can also be declared globally in the `intlayer.config.ts` file.
   *
   * Example:
   * ```json
   * {
   * "key": "about-page",
   * "fill": true
   * }
   * ```
   */
  fill?: Fill;

  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Indicates if the dictionary has been auto filled.
   * In the case of conflicts, base dictionaryed will override auto filled dictionary.
   */
  filled?: true;

  /**
   * Indicates the priority of the dictionary.
   * In the case of conflicts, the dictionary with the highest priority will override the other dictionaries.
   */
  priority?: number;

  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * Indicates the mode of import to use for the dictionary.
   *
   * Available modes:
   * - "static": The dictionaries are imported statically.
   * - "dynamic": The dictionaries are imported dynamically in a synchronous component using the suspense API.
   * - "live": The dictionaries are imported dynamically using the live sync API.
   *
   * Default: undefined
   */
  importMode?: 'static' | 'dynamic' | 'live';

  /**
   * Indicates the location of the dictionary and controls how it synchronizes with the CMS.
   *
   * - 'local&remote': The dictionary is managed locally and remotely. Once pushed on the CMS, it will be synchronized from the local one. The local dictionary will be pulled from the CMS.
   * - 'remote': The dictionary is managed remotely only. Once pushed on the CMS, it will be detached from the local one. At content load time, the remote dictionary will be pulled from the CMS. A '.content' file with remote location will be ignored.
   * - 'local': The dictionary is managed locally. It will not be pushed to the remote CMS.
   * - 'plugin' (or any custom string): The dictionary is managed by a plugin, or a custom source. When you will try to push it, the system will ask an action to the user.
   */
  location?: DictionaryLocation;
};

/**
 * Strict Schema Branch:
 * If a schema is provided, it MUST be one of the SchemaKeys.
 */
type DictionaryWithSchema<
  ContentType,
  FetchableNode,
  K extends SchemaKeys = SchemaKeys,
> = K extends any
  ? {
      schema: K;
      content: ContentType extends undefined
        ? ReplaceContentValue<Schema<K>, FetchableNode> | Schema<K>
        :
            | ReplaceContentValue<ContentType & Schema<K>, FetchableNode>
            | (ContentType & Schema<K>);
    }
  : never;

/**
 * No Schema Branch
 */
type DictionaryWithoutSchema<ContentType, FetchableNode> = {
  schema?: undefined;
  content: ContentType extends undefined
    ? any
    : ReplaceContentValue<ContentType, FetchableNode> | ContentType;
};

/**
 * The Final Dictionary Type
 */
export type Dictionary<
  ContentType = undefined,
  SchemaKey extends SchemaKeys | undefined = undefined,
  FetchableNode = false,
> = DictionaryBase &
  (SchemaKey extends SchemaKeys
    ? DictionaryWithSchema<ContentType, FetchableNode, SchemaKey>
    : undefined extends SchemaKey // Check if SchemaKey is missing/undefined
      ?
          | DictionaryWithoutSchema<ContentType, FetchableNode>
          | DictionaryWithSchema<ContentType, FetchableNode>
      : never);

export type GetSubPath<T, P> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? GetSubPath<T[K], Rest>
    : never
  : P extends keyof T
    ? T[P]
    : T;
