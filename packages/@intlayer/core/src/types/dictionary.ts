import type { ConditionContent } from '../transpiler/condition';
import type { EnumerationContent } from '../transpiler/enumeration';
import type { FileContent } from '../transpiler/file';
import type { GenderContent } from '../transpiler/gender';
import type { InsertionContent } from '../transpiler/insertion';
import type { MarkdownContent } from '../transpiler/markdown';
import type { NestedContent } from '../transpiler/nesting';
import type { TranslationContent } from '../transpiler/translation';
import type {
  IntlayerDictionaryTypesConnector,
  LanguageContent,
  LocalesValues,
} from './intlayer';

/**
 * Provides a fallback to string type if the generic type T is undefined,
 * otherwise returns T. This is useful for handling cases where no keys are found.
 * Example: StringFallback<undefined> -> string; StringFallback<'key'> -> 'key'
 */
export type StringFallback<T> = T extends undefined ? string : T; // If no keys are found, return string to disable error, and accept any string as dictionary key

/**
 * Represents the keys of the IntlayerDictionaryTypesConnector,
 * ensuring they are valid dictionary keys or fallback to string if none exist.
 *
 * Example:
 * ```ts
 * DictionaryKeys -> 'key1' | 'key2'
 * // or if IntlayerDictionaryTypesConnector is not defined,
 * DictionaryKeys -> string
 * ```
 */
export type DictionaryKeys = StringFallback<
  keyof IntlayerDictionaryTypesConnector
>;

type BaseNode = number | string | boolean | null | undefined;

export type TypedNode<NodeType = undefined> =
  | TranslationContent<NodeType>
  | EnumerationContent<NodeType>
  | ConditionContent<NodeType>
  | InsertionContent<NodeType>
  | MarkdownContent<NodeType>
  | NestedContent<DictionaryKeys>
  | GenderContent<NodeType>
  | FileContent;

type FetchableContentNode<NodeType> = (
  args?: any
) => ContentNode<NodeType> | Promise<ContentNode<NodeType>>;

export type ContentNode<
  T = undefined,
  FetchableNode = false,
  NodeType = T extends undefined ? BaseNode : T,
> =
  | NodeType
  | TypedNode<NodeType>
  | ((args?: any) => ContentNode<NodeType>)
  | (FetchableNode extends true ? FetchableContentNode<NodeType> : undefined);

// Utility types (unchanged)
type IsArray<T> = T extends any[] ? true : false;

type ReplaceContentValueArray<T, FetchableNode> = T extends (infer U)[]
  ? // Allow either a *single* typed node returning the entire array
    // or an array of typed nodes (or scalar nodes).
    ContentNode<T, FetchableNode> | ReplaceContentValue<U, FetchableNode>[]
  : never;

type ReplaceContentValueObject<T, FetchableNode> = {
  [K in keyof T]: ReplaceContentValue<T[K], FetchableNode>;
};

// Modified: allow a full ContentNode wrapper OR an object shape when T is an object
type ReplaceContentValue<
  NodeType,
  FetchableNode = true,
> = NodeType extends object
  ? IsArray<NodeType> extends true
    ? ReplaceContentValueArray<NodeType, FetchableNode>
    :
        | ContentNode<NodeType, FetchableNode>
        | ReplaceContentValueObject<NodeType, FetchableNode>
  : ContentNode<NodeType, FetchableNode>;

export type AutoFill = true | string | Partial<LanguageContent<string>>;

export type LocalDictionaryId = string;

export type Dictionary<ContentType = undefined, FetchableNode = false> = {
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The schema of the dictionary, used for JSON validation
   */
  $schema?: string;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For remote dictionaries, the id is the id of the dictionary in the remote server
   */
  id?: string;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Unique Identifier for the dictionaries. Auto generated by the intlayer, it helps to identify the dictionary and know if it is a local or remote dictionary, and his location.
   */
  localId?: LocalDictionaryId;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * For merged dictionaries, the localIds is the ids of the dictionaries that are merged
   */
  localIds?: LocalDictionaryId[];
  /**
   * The key of the dictionary. If multiple dictionaries have the same key, intlayer will merge them.
   *
   * As convention, use '-' to separate the words in the key.
   *
   * Example:
   * ```json
   * {
   *   "key": "about-page-meta",
   *   "content": { ... }
   * }
   * ```
   */
  key: string;
  /**
   * The title of the dictionary. Helps to identify the dictionary in the editor, and the CMS.
   *
   * Example:
   * ```json
   * {
   *   "key": "about-page-meta",
   *   "title": "About Page",
   *   "content": { ... }
   * }
   * ```
   */
  title?: string;
  /**
   * The description of the dictionary. Helps to understand the purpose of the dictionary in the editor, and the CMS.
   * The descrtion is also used as context for translations generation.
   *
   * Example:
   * ```ts
   * {
   *   "key": "about-page-meta",
   *   "description":[
   *     "This dictionary is manage the metadata of the About Page",
   *     "Consider good practices for SEO:",
   *     "- The title should be between 50 and 60 characters",
   *     "- The description should be between 150 and 160 characters",
   *   ].join('\n'),
   *   "content": { ... }
   * }
   * ```
   */
  description?: string;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The available versions of the remote dictionary. Helps to know the versions of the dictionary that are available.
   */
  versions?: string[];
  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * The version of the remote dictionary. Helps to know the version of the dictionary that is currently used.
   */
  version?: string;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * The file path of the local dictionary. Helps to know from what .content file the dictionary has been generated.
   */
  filePath?: string;
  /**
   * Helps to categorize the dictionaries. The tags can provide more context and instructions for the dictionary.
   *
   * Example:
   * ```json
   * {
   *   "key": "about-page-meta",
   *   "tags": ["metadata","about-page"]
   * }
   * ```
   */
  tags?: string[];
  /**
   * Transform the dictionary in a per-locale dictionary.
   * Each field declared in a per-locale dictionary will be transformed in a translation node.
   * If missing, the dictionary will be treated as a multilingual dictionary.
   * If declared, do not use translation nodes in the content.
   *
   * Example:
   * ```json
   * {
   *   "key": "about-page",
   *   "locale": "en",
   *   "content": {
   *     "multilingualContent": "English content"
   *   }
   * }
   * ```
   */
  locale?: LocalesValues;
  /**
   * Instruction to auto fill the dictionary.
   * Can also be declared globally in the `intlayer.config.ts` file.
   *
   * Example:
   * ```json
   * {
   *   "key": "about-page",
   *   "autoFill": true
   * }
   * ```
   * ```json
   * {
   *   "key": "about-page",
   *   "autoFill": "./aboutPage.content.json"
   * }
   * ```
   * ```json
   * {
   *   "key": "about-page",
   *   "autoFill": "/messages/{{locale}}/{{key}}/{{fileName}}.content.json"
   * }
   * ```
   * ```json
   * {
   *   "key": "about-page",
   *   "autoFill": {
   *     "fr": "./aboutPage.fr.content.json",
   *     "es": "./aboutPage.es.content.json"
   *   }
   * }
   * ```
   *
   */
  autoFill?: AutoFill;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Indicates if the dictionary has been auto filled.
   * In the case of conflicts, base dictionaryed will override auto filled dictionary.
   */
  autoFilled?: true;
  /**
   * Indicates the priority of the dictionary.
   * In the case of conflicts, the dictionary with the highest priority will override the other dictionaries.
   */
  priority?: number;
  /**
   * _Managable on the CMS, do not modify it locally_
   *
   * For remote dictionaries, indicates if the dictionary is live.
   *
   * Will need the `importMode` to be "live" to be effective in the `intlayer.config.ts` file. Will also need the live server to be running.
   *
   * A live dictionary will be fetched at runtime using the live sync API.
   *
   * If live, the dictionary will by transformed to include fetch functions.
   * If not live, the dictionary will be transformed at build time using "dynamic" mode to optimize the number of fetch queries, and load performance.
   *
   * If live but the fetch request fails, the dictionary will return the dynamic value of the dictionary as fallback.
   *
   */
  live?: boolean;
  /**
   * _Auto generated by the intlayer, do not modify it_
   *
   * Indicates the location of the dictionary.
   */
  location?: 'distant' | 'locale' | 'plugin';
  /**
   * The content of the dictionary.
   *
   * Example:
   * ```tsx
   * import { t, enu, cond, nest, md, insert, file } from "intlayer";
   *
   * export default {
   *   key: "about-page-meta",
   *   content: {
   *     stringContent: "About Page Meta",
   *     numberContent: 123,
   *     booleanContent: true,
   *     multilingualContent: t({
   *       en: "About Page Meta",
   *       fr: "Meta de la page About",
   *       es: "Meta de la página About",
   *     }),
   *     conditionalContent: cond({
   *       true: "About Page Meta",
   *       false: "About Page Meta",
   *     }),
   *     insertionContent: insert("About Page Meta"),
   *     nestedContent: nest("about-page"),
   *     markdownContent: md("# About Page Meta"),
   *     fileContent: file("./path/to/file.txt"),
   *     jsxContent: <h1>About Page Meta</h1>,
   *   },
   *
   * } satisfies Dictionary<Content>;
   * ```
   *
   * ```json
   * {
   *   "key": "about-page-meta",
   *   "content": {
   *    "stringContent": "About Page Meta",
   *    "numberContent": 123,
   *    "booleanContent": true,
   *    "multilingualContent": {
   *      "nodeType": "translation",
   *      "translation": {
   *        "en": "About Page Meta",
   *        "fr": "Meta de la page About",
   *        "es": "Meta de la página About",
   *      },
   *    },
   *    "conditionalContent": {
   *      "nodeType": "condition",
   *      "condition": {
   *        "true": "About Page Meta",
   *        "false": "About Page Meta",
   *      },
   *    },
   *    "insertionContent": {
   *      "nodeType": "insertion",
   *      "insertion": "About Page Meta",
   *    },
   *    "nestedContent": {
   *      "nodeType": "nested",
   *      "nested": { "dictionaryKey": "about-page" },
   *    },
   *    "markdownContent": {
   *      "nodeType": "markdown",
   *      "markdown": "# About Page Meta",
   *    },
   *    "fileContent": {
   *      "nodeType": "file",
   *      "file": "./path/to/file.txt",
   *    },
   *  }
   * }
   * ```
   */
  content: ContentType extends undefined // Applying the generic to replace ContentValue with Replacement
    ? any
    : ReplaceContentValue<ContentType, FetchableNode> | ContentType;
};

export type GetSubPath<T, P> = P extends `${infer K}.${infer Rest}`
  ? K extends keyof T
    ? GetSubPath<T[K], Rest>
    : never
  : P extends keyof T
    ? T[P]
    : T;
